{
  "$meta": {
    "description": "Use `if` blocks to do different things depending on some condition. Include zero or more `else if` blocks and one optional `else` block. Use a `while` block to loop as long as a condition is true. A `for` loop can loop over any `list`, including ones easily created with the `range` function. The `break` statement jumps out of a `while` or `for` loop. The `continue` statement jumps to the top of the loop, skipping the rest of the current iteration.",
    "example": [
      "// if block",
      "if 2+2 == 4 then",
      "   print \"math works!\"",
      "else if pi > 3 then",
      "   print \"pi is tasty\"",
      "else if \"a\" < \"b\" then",
      "   print \"I can sort\"",
      "else",
      "   print \"last chance\"",
      "end if",
      "",
      "// while loop",
      "s = \"Spam\"",
      "while s.len < 50",
      "   s = s + \", spam\"",
      "end while",
      "print s + \" and spam!\"",
      "",
      "// for loop",
      "for i in range(10, 1)",
      "   print i + \"...\"",
      "end for",
      "print \"Liftoff!\""
    ]
  },
  "mail_login": {
    "description": "Returns a `MetaMail` entity if the login was successful. On failure a `string` with details gets returned. In case any of the provided values deviate from the types defined in the signature this method will return `null`.",
    "example": [
      "metaMail = mail_login(\"test@test.com\", \"test\")",
      "if metaMail == null then",
      "   print(\"Loggin failed.\")",
      "else",
      "   print(\"You've got mail.\")",
      "end if"
    ]
  },
  "parent_path": {
    "description": "Returns a `string` which is the parent path of the provided path. The path provided needs to be properly formatted. If the path is any other type than a `string` or is empty, this method will throw an error interrupting further script execution.",
    "example": [
      "print(\"Is proper parent path: \" + (parent_path(\"/my/test/path\") == \"/my/test\"))"
    ]
  },
  "hasIndex": {
    "description": "Verifies if an index is available within an object. In case of success this method will return a `number` with the value one. In case of failure the value will be a zero. This method supports `map`s, `list`s and `string`s. Each passed type may result in different behavior therefore it is advisable to take a look at each of their specific signatures. In case an unsupported value gets passed this method will return `null`.",
    "example": [
      "print(\"List has index: \" + hasIndex([1, 2, 3], 2)"
    ]
  },
  "typeof": {
    "description": "Returns a `string` containing the type of the entity provided. There are following types by default: `\"aptclientLib\"`, `\"blockchainLib\"`, `\"ctfEvent\"`, `\"coin\"`, `\"computer\"`, `\"cryptoLib\"`, `\"file\"`, `\"function\"`, `\"list\"`, `\"map\"`, `\"MetaLib\"`, `\"MetaMail\"`, `\"MetaxploitLib\"`, `\"NetSession\"`, `\"null\"`, `\"number\"`, `\"port\"`, `\"router\"`, `\"service\"`, `\"shell\"`, `\"ftpshell\"`, `\"string\"`, `\"subwallet\"`, `\"wallet\"`. Custom types can be added as well by using the `classID` property in a `map`.",
    "example": [
      "myObj = { \"classID\": \"myType\" }",
      "if typeof(myObj) == \"myType\" then",
      "   print(\"Object is myType.\")",
      "else",
      "   print(\"Object is not myType.\")",
      "end if"
    ]
  },
  "get_router": {
    "description": "Returns by default the `router` to which the executing computer is connected to. Optionally an IP address can be provided. In case of failure `null` is returned. If there is no active internet connection, this method will throw an error, interrupting further script execution.",
    "example": [
      "router = get_router",
      "if router.local_ip == get_shell.host_computer.network_gateway then",
      "   print(\"Router is equal to network gateway.\")",
      "else",
      "   print(\"Router is not equal to network gateway.\")",
      "end if"
    ]
  },
  "get_switch": {
    "description": "Returns the switch on the local network whose IP address matches, otherwise it returns `null`.",
    "example": [
      "router = get_switch(\"192.168.0.2)",
      "print(\"IP address of switch: \" + router.local_ip)"
    ]
  },
  "nslookup": {
    "description": "Returns the IP address for the provided web address. In case the web address cannot be found a `string` gets returned containing the following message: `\"Not found\"`. If the provided web address is not a `string` or empty this method will throw an error preventing further script execution.",
    "example": [
      "url = params[0]",
      "print(\"IP for website is: \" + nslookup(url))"
    ]
  },
  "print": {
    "description": "Print a message on the Terminal. Optionally replacing can be enabled which will replace all previous prints. This can be useful for creating a loading bar for example. There is also the possibility of styling output by using TextMeshPro rich-text tags.",
    "example": [
      "for i in range(9)",
      "   print((\"#\" * (9 - i)) + (\"-\" * i) , true)",
      "   wait(0.2)",
      "end for"
    ]
  },
  "clear_screen": {
    "description": "Removes any text existing in a Terminal prior to this point. Utilizing this method in an SSH encryption process will trigger an error, halting further script execution.",
    "example": [
      "for i in range(9)",
      "   clear_screen",
      "   print((\"#\" * (9 - i)) + (\"-\" * i))",
      "   wait(0.2)",
      "end for"
    ]
  },
  "active_user": {
    "description": "Returns a `string` with the name of the user who is executing the current script.",
    "example": [
      "print(\"Current active user: \" + active_user)"
    ]
  },
  "home_dir": {
    "description": "Returns a `string` with the home folder path of the user who is executing the current script.",
    "example": [
      "print(\"Home dir of current user: \" + home_dir)"
    ]
  },
  "get_shell": {
    "description": "Returns the `shell` that is executing the current script. Optionally, a username and password can be provided, allowing the use of a shell with other user privileges. If the username or password does not match an existing user or if the provided values deviate from the defined signature, this method will return `null`.",
    "example": [
      "shell = get_shell(\"root\", \"test\")",
      "if shell == null then",
      "   print(\"Couldn't obtain root shell.\")",
      "else",
      "   print(\"Obtained root shell.\")",
      "end if"
    ]
  },
  "indexes": {
    "description": "Returns a `list` containing all indexes or keys of the passed object. This method supports `map`s, `list`s, and `string`s. The type of each item may vary when using this method on a `map` since keys could be any type. The other types will return a `list` where each item is a `number`. In case a type is passed that is not supported, this method will return `null`.",
    "example": [
      "indexesOfStr = indexes(\"test\")",
      "print(\"Following indexes are available: \" + indexesOfStr.join(\", \"))"
    ]
  },
  "values": {
    "description": "Depending on data type this function returns a `list` with all available values. To get a better idea about the behaviour look into the `values` methods related to `string`, `list` and `map`.",
    "example": [
      "indexesOfStr = values(\"test\")",
      "print(\"Following values are available: \" + indexesOfStr.join(\", \"))"
    ]
  },
  "indexOf": {
    "description": "Lookups index of value within `map`s, `list`s, or `string`s. For `list`s and `string`s, the behavior is very similar. On success, you'll receive a `number` representing the found index. On failure, it will return `null`. For `map`s, it's a bit different since the returned value could be of any type. On failure, it will return `null` as well. If a value gets passed that is not supported, this method returns `null`.",
    "example": [
      "index = indexOf(\"test\", \"e\")",
      "print(\"e is at: \" + index)"
    ]
  },
  "len": {
    "description": "Returns `number` indicating what size the passed object is. In case anything other that a `map`, `list` or `string` gets passed this method will return `null`.",
    "example": [
      "length = len(\"test\")",
      "print(\"Length of string is: \" + length)"
    ]
  },
  "shuffle": {
    "description": "Depending on data type this function will shuffle data. Instead of returning the newly shuffled data, this function will mutate the data. To get a better idea about the behaviour look into the `shuffle` methods related to `list` and `map`.",
    "example": [
      "list = [0, 1, 2, 3, 4, 5]",
      "shuffle(list)",
      "print(\"And the winner is: \" + list[0])"
    ]
  },
  "val": {
    "description": "Casts a `string` to a `number`. In case the provided `string` does not represent a valid `number` the `number` zero will get returned.",
    "example": [
      "num = val(\"1.25\")",
      "print(\"Number in string is: \" + num)"
    ]
  },
  "lower": {
    "description": "Returns a `string` which is the lowercase transformed version of the provided `string`. In case anything other than a `string` gets passed this method will return the passed value again.",
    "example": [
      "myString = lower(\"HELLO WORLD\")",
      "print(myString)"
    ]
  },
  "upper": {
    "description": "Returns a `string` which is the uppercase transformed version of the provided `string`. In case anything other than a `string` gets passed this method will return the passed value again.",
    "example": [
      "myString = upper(\"hello world\")",
      "print(myString)"
    ]
  },
  "sum": {
    "description": "Depending on data type this function returns the sum of all items. To get a better idea about the behaviour look into the `sum` methods related to `list` and `map`.",
    "example": [
      "list = [0, 1, 2, 3, 4, 5]",
      "print(\"Sum of all items is: \" + sum(list))"
    ]
  },
  "pop": {
    "description": "When passing a `list` to this method, it will return the value at the last index and remove it from the `list`. Additionally, if a `map` is passed, it will always return the value corresponding to the first matching key and mutate the `map` object accordingly. However, passing a map-like object such as `file` or `computer` will result in an error, interrupting further script execution. If the passed object is empty or is anything other than a `map` or `list`, the method will return `null`.",
    "example": [
      "list = [0, 1, 2, 3, 4, 5]",
      "print(\"The last item is: \" + pop(list))"
    ]
  },
  "pull": {
    "description": "When passing a `list` to this method, it will return the value at the first index and remove it from the `list`. Additionally, if a `map` is passed, it will always return the value corresponding to the first matching key and mutate the `map` object accordingly. However, passing a map-like object such as `file` or `computer` will result in an error, interrupting further script execution. If the passed object is empty or is anything other than a `map` or `list`, the method will return `null`.",
    "example": [
      "list = [0, 1, 2, 3, 4, 5]",
      "print(\"The first item is: \" + pull(list))"
    ]
  },
  "push": {
    "description": "Depending on data type this function will append a value to the provided object. As a result, the object will get mutated. To get a better idea about the behaviour look into the `push` methods related to `list` and `map`.",
    "example": [
      "list = [0, 1, 2, 3, 4, 5]",
      "push(list, 42)",
      "print(\"The answer to everything is: \" + pop(list))"
    ]
  },
  "sort": {
    "description": "Sort `list` values alphanumerically. This operation will mutate the `list`. Optionally a key can be provided which which is used in case the items are maps. Additionally, this method will return the updated `list`.",
    "example": [
      "list = [9, 3, 5, 7]",
      "sort(list)",
      "print(\"Sorted list: \" + list.join(\", \"))"
    ]
  },
  "remove": {
    "description": "Depending on the data type, this function will remove a value in the provided object, potentially mutating the object. This method works with `map`s, `list`s, and `string`s. Each passed type may support different types for the `key` argument. For example, using this method on a string would treat the key as a character index. Therefore, it is advised to review the signatures of each type. Passing a key with the type `null` may cause an error to be thrown, preventing further script execution. The same will happen if the passed self value deviates from being a `map`, `list`, or `string`.",
    "example": [
      "list = [9, 3, 5, 7]",
      "remove(list, 5)",
      "print(\"List after removal: \" + list.join(\", \"))"
    ]
  },
  "user_input": {
    "description": "Puts script execution on hold to receive input from the user. Input can be submitted by pressing Enter. You can style the output message using TextMeshPro rich-text tags. Two optional arguments are available: `isPassword`, which defines whether input should be masked by asterisk signs, and `anyKey`, which enables capturing of keys individually. Using this method within an SSH encryption process or passing values deviating from the defined method signature will cause an error to be thrown, interrupting further script execution.",
    "example": [
      "num = 0",
      "aboveIncludingZeroTag = \"<color=yellow>\"",
      "belowZeroTag = \"<color=red>\"",
      "while (true)",
      "   clear_screen",
      "   output = aboveIncludingZeroTag + num",
      "   if (num < 0) then",
      "      output = belowZeroTag + num",
      "   end if",
      "   print(output)",
      "   key = user_input(\"Press arrow up/down to change value.\", false, true)",
      "   if (key == \"UpArrow\") then",
      "      num = num + 1",
      "   else if (key == \"DownArrow\") then",
      "       num = num - 1",
      "   else",
      "       exit(\"Bye!\")",
      "   end if",
      "end while"
    ]
  },
  "include_lib": {
    "description": "Enables the inclusion of library binaries, which can be used inside your script. If successful, an object related to the provided library will be returned; otherwise, `null` is returned. This function is exclusively for importing library binaries. If you want to import custom scripts or binaries into your project, use `import_code` instead. Passing anything other than a `string` for the path, or leaving the path empty, will cause an error to be thrown, interrupting further script execution.",
    "example": [
      "crypto = include_lib(\"/lib/crypto.so\")",
      "if crypto == null then",
      "   print(\"Crypto library couldn't get imported.\")",
      "else",
      "   print(\"Crypto library got imported.\")",
      "end if"
    ]
  },
  "import_code": {
    "description": "Enables to import code from different sources into one file. This is useful in case you want to split code into different files and also to avoid any limitation in regards to text file character limits. Note that `import_code` requires an absolute path and is called while compiling the file into a binary instead of during runtime. Additionally `import_code` cannot be nested. Code can be either imported from plain text files or binaries that have `\"allow import\"` enabled. `import_code` is also parsed wherever it is found, not even a `//` comment will prevent it being evaluated.",
    "example": [
      "//Content of main.src",
      "import_code(\"/home/user/my_module.src\")",
      "print(\"bye\")",
      "//Content of my_module.src",
      "print(\"hello!\")"
    ]
  },
  "exit": {
    "description": "Stops execution of the currently running script. Optionally a message can be provided which will be shown in the Terminal. There is also the possibility of styling output by using TextMeshPro rich-text tags.",
    "example": [
      "while (true)",
      "   shouldExit = lower(user_input(\"Want to exit? (Y/N)\"))",
      "   if (shouldExit == \"y\") then",
      "      exit(\"See you!\")",
      "   end if",
      "end while"
    ]
  },
  "user_mail_address": {
    "description": "Returns a `string` containing the email address of the player who is executing the script. If the user does not have an email address this method will return `null`.",
    "example": [
      "print(\"My EMail address is: \" + user_mail_address)"
    ]
  },
  "user_bank_number": {
    "description": "Returns a `string` containing the bank account number of the player who is executing the script. If the user does not have a bank this method will return `null`.",
    "example": [
      "print(\"My Bank number is: \" + user_bank_number)"
    ]
  },
  "whois": {
    "description": "Returns a `string` containing the administrator information behind an IP address provided. In case of failure the returned `string` will contain an error message instead. If the provided ip is not a `string` or is empty this method will throw an error causing the script to stop.",
    "example": [
      "adminInfo = whos(\"1.1.1.1\")",
      "infoLines = adminInfo.split(char(10))",
      "infoObject = {}",
      "infoObject.domainName = infoLines[0].split(\":\")[1].trim",
      "infoObject.administrativeContact = infoLines[1].split(\":\")[1].trim",
      "infoObject.emailAddress = infoLines[2].split(\":\")[1].trim",
      "infoObject.phone = infoLines[3].split(\":\")[1].trim",
      "print(\"Phone number: \" + infoObject.phone)"
    ]
  },
  "wait": {
    "description": "Puts script execution on hold. Optionally the duration can be provided via the time argument. By default, the duration will be 1 second. The duration cannot be below 0.01 or above 300.",
    "example": [
      "start = time",
      "wait(5)",
      "elapsed = time - start",
      "print(\"Waited: \" + elapsed)"
    ]
  },
  "command_info": {
    "description": "Returns a `string` value of a translation. Translations include commands, documentation and other game-related things. Checkout [Grey-Texts](https://github.com/LoadingHome/Grey-Texts/blob/main/EnglishLang.json) for an overview of all available keys. If the provided command name is not a `string` or is empty this method will throw an error causing the script to stop.",
    "example": [
      "print(command_info(\"LS_USAGE\"))"
    ]
  },
  "program_path": {
    "description": "Returns a `string` containing the path of the script that is currently executed.",
    "example": [
      "path = program_path",
      "print(\"Script gets executed within: \" + parent_path(path))"
    ]
  },
  "current_path": {
    "description": "Returns a `string` containing the path in which script that is currently executed from.",
    "example": [
      "path = current_path",
      "print(\"PWD: \" + path)"
    ]
  },
  "format_columns": {
    "description": "Returns a `string` which is the formatted version of the provided text. Keep in mind that TextMeshPro rich-text tags might screw up the output. When using tags consider applying these after formatting. Passing anything other than a `string` will result in an empty `string`.",
    "example": [
      "text = \"FIRST SECOND THIRD",
      "1 2 3\"",
      "print(format_columns(text))"
    ]
  },
  "current_date": {
    "description": "Returns a `string` containing the current date and time. Ingame time passes 15 times as fast as real-time - 4 seconds per in-game minute. The initial time after every wipe will be the 1st of January 2000 at 6:00 AM. Additionally, the game time will not proceed while the server is offline.\n* Output schema: `\"[day]/[month]/[year] - [hours]:[minutes]\"`\n* Example output: `\"27/Jan/2000 - 08:19\"`\n",
    "example": [
      "dateStr = current_date",
      "dateSegments = dateStr.split(\" - \")",
      "date = dateSegments[0].split(\"/\")",
      "day = date[0]",
      "month = date[1]",
      "year = date[2]",
      "dateTime = dateSegments[1].split(\":\")",
      "hours = dateTime[0]",
      "minutes = dateTime[1]",
      "print(\"Current day: \" + day)"
    ]
  },
  "is_lan_ip": {
    "description": "Returns a `number`. One indicates that the provided IP address is a valid LAN IP address. Otherwise, zero will be returned.",
    "example": [
      "print(\"Is Lan IP: \" + is_lan_ip(\"192.168.0.1\"))"
    ]
  },
  "is_valid_ip": {
    "description": "Returns a `number`. If the provided IP address is valid, its value will be one. Otherwise, its value is zero.",
    "example": [
      "print(\"Is valid IP: \" + is_valid_ip(\"1.1.1.1\"))"
    ]
  },
  "bitwise": {
    "description": "Returns a `number` by performing bitwise operations. Supported operators are: `\"~\", \"&\"`, `\"|\"`, `\"^\"`, `\"<<\"`, `\">>\"`, `\">>>\"`. In case you want to use the tilde operator you only need to provide the operator and the left argument. If any of the required arguments is `null` this method will return `null`. Warning: If either operand is >= `0x80000000`, it'll always returns 0.",
    "example": [
      "num = params[0].to_int",
      "isOdd = bitwise(\"&\", num, 1) == 1",
      "if isOdd then",
      "   print(\"Number is odd.\")",
      "else",
      "   print(\"Number is even.\")",
      "end if"
    ]
  },
  "abs": {
    "description": "Returns the absolute value of `number`.",
    "example": [
      "a = 1",
      "b = 5",
      "difference = abs(a - b)",
      "print(\"Difference between a and b is: \" + difference)"
    ]
  },
  "acos": {
    "description": "Returns the inverse cosine (in radians) of a `number`.",
    "example": [
      "adjacent = 8",
      "hypotenuse = 10",
      "calcAngle = acos(adjacent / hypotenuse)",
      "print(\"Angle: \" + calcAngle)"
    ]
  },
  "asin": {
    "description": "Returns the inverse sine (in radians) of a `number`.",
    "example": [
      "opposite = 6",
      "hypotenuse = 10",
      "calcAngle = acos(opposite / hypotenuse)",
      "print(\"Angle: \" + calcAngle)"
    ]
  },
  "atan": {
    "description": "Returns the inverse tangent (in radians) of a `number`.",
    "example": [
      "opposite = 8",
      "hypotenuse = 10",
      "calcAngle = atan(opposite / hypotenuse)",
      "print(\"Angle: \" + calcAngle)"
    ]
  },
  "tan": {
    "description": "Returns the tangent of a `number` in radians.",
    "example": [
      "degrees = 90",
      "tanFromDegrees = tan(degress * pi / 180)",
      "print(\"Tan from degrees: \" + tanFromDegrees)"
    ]
  },
  "cos": {
    "description": "Returns the cosine of a `number` in radians.",
    "example": [
      "radians = 1",
      "radius = 10",
      "circleX = cos(radians) * radius",
      "print(circleX)"
    ]
  },
  "code": {
    "description": "Returns the Unicode `number` of the first character of the string. In case an empty `string` is provided the script execution will crash.",
    "example": [
      "key = user_input(\"Press a key!\", false, true)",
      "isA = key.code == 97",
      "if isA then",
      "   print(\"You pressed A.\")",
      "else",
      "   print(\"You did not press A.\")",
      "end if"
    ]
  },
  "char": {
    "description": "Returns the UTF-16 character `string` related to the provided unicode `number`. The provided `number` needs to be between 0 and 65535. Any `number` which is outside this range will cause the script to throw a runtime error. Beware when passing non-ASCII values to intrinsics as they will likely get re-encoded as UTF-8. For example, `md5(char(255))` will actually return the hash of the two-byte sequence `0xC3` `0xBF`.",
    "example": [
      "key = user_input(\"Press a key!\", false, true)",
      "isA = key == char(97)",
      "if isA then",
      "   print(\"You pressed A.\")",
      "else",
      "   print(\"You did not press A.\")",
      "end if"
    ]
  },
  "sin": {
    "description": "Returns the sine of a `number` in radians.",
    "example": [
      "radians = 1",
      "radius = 10",
      "circleY = sin(radians) * radius",
      "print(circleY)"
    ]
  },
  "floor": {
    "description": "Returns `number` rounded down to the integer value of the provided `number`.",
    "example": [
      "price = 25.43467",
      "floored = floor(price * 100) / 100",
      "print(\"Floored price: \" + floored)"
    ]
  },
  "range": {
    "description": "Returns a `list` where each item is a `number`. By default, the `list` starts with the `number` zero and increments by one for each item. Optionally start and end can be defined. Additionally, the incremental value can be changed as well. In case the incremental value is zero this function will throw a runtime error.",
    "example": [
      "print(\"Countdown:\")",
      "for num in range(10)",
      "   print(num)",
      "end for",
      "print(\"Done!\")"
    ]
  },
  "round": {
    "description": "Returns `number` rounded to the integer value of the provided `number`.",
    "example": [
      "price = 25.43467",
      "rounded = round(price * 100) / 100",
      "print(\"Price: \" + rounded)"
    ]
  },
  "rnd": {
    "description": "Returns a random `number` between 0 and 1. Optionally a seed `number` can be provided.",
    "example": [
      "min = 10",
      "max = 20",
      "output = floor(rnd * (max - min + 1) + min)",
      "input = user_input(\"Guess a number between 10 and 20!\").to_int",
      "if (input == output) then",
      "   print(\"You guessed right!\")",
      "else",
      "   print(\"You failed! The number was \" + output)",
      "end if"
    ]
  },
  "sign": {
    "description": "Returns a one or minus one, indicating the sign of the number passed as argument. If the input is zero, it will be returned as-is.",
    "example": [
      "print(sign(40))",
      "print(sign(-40))",
      "print(sign(0))"
    ]
  },
  "sqrt": {
    "description": "Returns the square root of a `number`.",
    "example": [
      "a = 3",
      "b = 4",
      "calcHypotenuse = sqrt((a * a) + (b * b))",
      "print(\"Hypotenuse: \" + calcHypotenuse)"
    ]
  },
  "str": {
    "description": "Returns the `string` value of provided data. Can be used to turn a `number` into a `string` or to get the signature of a `function`.",
    "example": [
      "signature = str(@user_input)",
      "argSegment = signature[9:signature.len - 1]",
      "args = argSegment.split(\",\")",
      "print(\"Function has \" + args.len + \" arguments.\")"
    ]
  },
  "ceil": {
    "description": "Returns `number` rounded up to the integer value of the provided `number`.",
    "example": [
      "price = 25.43467",
      "upperPrice = ceil(price * 100) / 100",
      "print(\"Upper price: \" + upperPrice)"
    ]
  },
  "pi": {
    "description": "Returns the `number` PI to the precision of six.",
    "example": [
      "radius = 10",
      "circumference = 2 * pi * radius",
      "print(\"Circumference: \" + circumference)"
    ]
  },
  "launch": {
    "description": "Launches the binary which is at the provided path. Optionally parameters can be passed. Returns `true` when launch was successful otherwise this method will return `false`. Cannot be used to execute binaries with an EXE extension.",
    "example": [
      "shell = get_shell(\"root\", \"test\")",
      "launch(shell, \"/bin/cat\", \"/etc/passwd\")"
    ]
  },
  "launch_path": {
    "description": "Returns a `string` containing the path of the script that is currently executed.",
    "example": [
      "path = program_path",
      "print(\"Script gets executed within: \" + parent_path(path))"
    ]
  },
  "slice": {
    "description": "Returns a sliced `list`. Valid data types for slicing are `string` and `list`. The returned `list` will contain all elements related to the provided start and end index.",
    "example": [
      "myString = \"not your text\"",
      "print(\"my \" + slice(myString, 9))"
    ]
  },
  "md5": {
    "description": "Returns the MD5 hash `string` of the provided `string`. Using this method within an SSH encryption process or passing anything other than a `string` will cause an error to be thrown, stopping any further script execution.",
    "example": [
      "passwordHash = md5(\"test\")",
      "print(\"Hash for the password 'test' is \" + passwordHash)"
    ]
  },
  "hash": {
    "description": "Returns numeric hash for the provided data. Using this method within a SSH encryption process will cause an error to be thrown causing the script execution to stop.",
    "example": [
      "hashA = hash({ \"a\": 2, \"b\": 1 })",
      "hashB = hash({ \"b\": 1, \"a\": 2 })",
      "if (hashA == hashB) then",
      "   print(\"Objects are alike!\")",
      "else",
      "   print(\"Objects are different!\")",
      "end if"
    ]
  },
  "time": {
    "description": "Returns a `number` of seconds representing the elapsed time since the script got started.",
    "example": [
      "start = time",
      "for i in range(10000)",
      "   var = i * 100",
      "end for",
      "endTime = time - start",
      "print(\"Script execution done within: \" + endTime)"
    ]
  },
  "bitAnd": {
    "description": "Performs a bitwise AND for the provided values. Returns a `number`. Warning: If either operand is >= `0x80000000`, it'll always return 0.",
    "example": [
      "print(\"Result of bitwise AND: \" + bitAnd(1, 2))"
    ]
  },
  "bitOr": {
    "description": "Performs a bitwise OR for the provided values. Returns a `number`. Warning: If either operand is >= `0x80000000`, it'll always return 0.",
    "example": [
      "print(\"Result of bitwise OR: \" + bitOr(1, 2))"
    ]
  },
  "bitXor": {
    "description": "Performs a bitwise XOR for the provided values. Returns a `number`. Warning: If either operand is >= `0x80000000`, it'll always return 0.",
    "example": [
      "print(\"Result of bitwise XOR: \" + bitXor(1, 2))"
    ]
  },
  "log": {
    "description": "Returns the natural logarithm of a `number`. By default, the base is 10. Optionally the base can be changed.",
    "example": [
      "a = 2",
      "b = 8",
      "baseLog = log(a) / log(b)",
      "print(\"Base log is: \" + baseLog)"
    ]
  },
  "yield": {
    "description": "Waits for the next tick.",
    "example": [
      "while (true)",
      "   yield",
      "   print(\"tick\")",
      "end while"
    ]
  },
  "get_custom_object": {
    "description": "Returns `map` which is shared throughout script execution. Can be helpful if it desired to pass or receive values when using `launch`. Using this method in a SSH encryption process will cause an error to be thrown preventing further script execution.",
    "example": [
      "get_custom_object.shouldEndScript = false",
      "while (get_custom_object.shouldEndScript)",
      "   print(\"Waiting...\")",
      "   wait(2)",
      "end while"
    ]
  },
  "insert": {
    "description": "Inserts a value into either a `list` or a `string`. If the method is used on any other data type or the passed index is not a `number`, this method throws an error, preventing further script execution.",
    "example": [
      "list = [2, 3, 4]",
      "insert(list, 2, 42)",
      "print(\"List with inserted item: \" + list.join(\", \"))"
    ]
  },
  "to_int": {
    "description": "Returns a `number` which is parsed from the `string` as an integer. In case the `string` is not numeric it will return the original `string`. If the passed value is not a `string` this method will return `null`.",
    "example": [
      "myString = \"1\"",
      "print(to_int(myString) + 41)"
    ]
  },
  "join": {
    "description": "Returns a concatenated `string` containing all stringified values inside the `list`. These values will be separated via the provided separator. Passing anything other than a `list` will result in the original value being returned. In case the passed `list` exceeds `16777215L` items or the delimiter exceeds 128 characters, this method will throw an error, interrupting further script execution.",
    "example": [
      "myList = [42, 1, 3]",
      "print(join(myList, \" .-*'*-. \"))"
    ]
  },
  "split": {
    "description": "Returns a `list` where each item is a segment of the `string`, separated by the provided separator `string`. This method uses regular expressions for matching, so remember to escape special characters such as dots. If any of the provided arguments deviate from the method signature types, this method will return `null`. In case the pattern is empty, the provided [regexOptions](https://learn.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-options) are invalid, or the regular expression times out, an error will be thrown, preventing further script execution.",
    "example": [
      "myString = \"42 as an answer is wrong\"",
      "segments = split(myString, \" \")",
      "if segments[0] != \"42\" then",
      "   print(\"Invalid information spotted!\")",
      "else",
      "   print(\"Information seems valid!\")",
      "end if"
    ]
  },
  "replace": {
    "description": "Depending on the data type this function will replace a value in the provided object. Due to the replacement, the object might get mutated. To get a better idea about the behaviour look into the `replace` method related to `map`, `list` or `string`.",
    "example": [
      "myString = \"42 as an answer is wrong\"",
      "newString = replace(myString, \"wrong\", \"right\")",
      "print(newString)"
    ]
  },
  "replace_regex": {
    "description": "Returns a `string` with the replaced content by using regular expressions. If any provided arguments deviate from the method signature types, if the pattern is empty, if the provided [regexOptions](https://learn.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-options) are invalid or if the regular expression times out, an error will be thrown, preventing further script execution.",
    "example": [
      "myString = \"42 as an answer is wrong\"",
      "newString = replace_regex(myString, \"\\w+$\", \"right\")",
      "print(newString)"
    ]
  },
  "is_match": {
    "description": "Uses regular expression to check if a string matches a certain pattern. If it matches, it will return a `number` with the value one. If it does not match, the value of the `number` will be zero. If any provided arguments deviate from the method signature types, if the pattern is empty, if the provided [regexOptions](https://learn.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-options) are invalid, or if the regular expression times out, an error will be thrown, preventing further script execution.",
    "example": [
      "myString = \"42 as an answer is wrong\"",
      "hasWordAtTheEnd = is_match(myString, \"\\w+$\")",
      "print(hasWordAtTheEnd)"
    ]
  },
  "matches": {
    "description": "Returns a `map` with all search results for the provided regular expression. Each key contains the index and the value contains the matching `string`. If any provided arguments deviate from the method signature types, if the pattern is empty, if the provided [regexOptions](https://learn.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-options) are invalid, or if the regular expression times out, an error will be thrown, preventing further script execution.",
    "example": [
      "myString = \"42 as an answer is wrong\"",
      "result = matches(myString, \"w\")",
      "print(result)"
    ]
  },
  "get_ctf": {
    "description": "Returns `ctfEvent` object if there is one available. In case of failure this method will return a `string` with details."
  },
  "show": {
    "description": "Displays all the packages available in a repository. The repository must be listed in the `\"/etc/apt/sources.txt\"` file. If any of the provided parameters have a type that deviates from the defined signature, the method will return `null`. If it cannot find a repository, it will return a string with an error message. On success, it will return a `string` containing all packages and their descriptions, with each entry separated by a newline.",
    "example": [
      "aptClient = include_lib(\"/lib/aptclient.so\")",
      "packages = show(aptClient, \"177.202.15.132\")",
      "packageList = split(packages, char(10) + char(10))",
      "pop(packageList) // remove last empty item",
      "for packageItem in packageList",
      "    entry = split(packageItem, char(10))",
      "    packageName = entry[0]",
      "    packageDescription = entry[1]",
      "    print \"Title: <b>\" + packageName + \"</b>\"",
      "    print \"Description: <i>\" + packageDescription + \"</i>\"",
      "    print \"----------------------------\"",
      "end for"
    ]
  },
  "search": {
    "description": "The `search` method specifically looks for a package in any of the repositories listed in `\"/etc/apt/sources.txt\"`. If any of the provided parameters have a type that deviates from the defined signature, the method will return `null`. On success, it will return a `string` containing all packages that partially match the provided search value. On failure, it will return a `string` with various error messages.",
    "example": [
      "aptClient = include_lib(\"/lib/aptclient.so\")",
      "packages = search(aptClient, \".so\")",
      "packageList = split(packages, char(10) + char(10))",
      "for packageItem in packageList",
      "    entry = split(packageItem, char(10))",
      "    if len(entry) != 2 then",
      "        print \"something wrong in: \" + entry",
      "        continue",
      "    end if",
      "    packageName = entry[0]",
      "    packageDescription = entry[1]",
      "    print \"Title: <b>\" + packageName + \"</b>\"",
      "    print \"Description: <i>\" + packageDescription + \"</i>\"",
      "    print \"----------------------------\"",
      "end for"
    ]
  },
  "update": {
    "description": "Refreshes the list of available packages after adding a new repository in `\"/etc/apt/sources.txt\"`, or if the remote repository has updated its information in `\"/server/conf/repod.conf\"`. If either the `\"/etc/apt/sources.txt\"` file has an invalid format or an invalid `GreyMap` instance is passed, this method will return a `number` with the value zero. If a `GreyMap` value is passed that isn't a valid `aptClient` instance, this method will return `null`. On a successful update, an empty `string` will be returned. In case of failure, a `string` with an error message will be returned.",
    "example": [
      "aptClient = include_lib(\"/lib/aptclient.so\")",
      "result = update(aptClient)",
      "if result == \"\" then",
      "    print \"Update successful!\"",
      "else",
      "    print \"Error while updating: \" + result",
      "end if"
    ]
  },
  "add_repo": {
    "description": "Adds a repository address to the `\"/etc/apt/sources.txt\"` file. If any of the provided parameters have a type that deviates from the defined signature, the method will return `null`. On success, it will return an empty `string`. In case of failure, it will return a `string` with an error message.",
    "example": [
      "aptClient = include_lib(\"/lib/aptclient.so\")",
      "result = add_repo(aptClient, \"177.202.15.132\")",
      "if result == \"\" then",
      "    print \"Addition successful!\"",
      "else",
      "    print \"Error while adding: \" + result",
      "end if"
    ]
  },
  "del_repo": {
    "description": "Removes a repository address from the `\"/etc/apt/sources.txt\"` file. If any of the provided parameters have a type that deviates from the defined signature, the method will return `null`. On success, it will return an empty `string`. In case of failure, it will return a `string` with an error message.",
    "example": [
      "aptClient = include_lib(\"/lib/aptclient.so\")",
      "result = del_repo(aptClient, \"177.202.15.132\")",
      "if result == \"\" then",
      "    print \"Deletion successful!\"",
      "else",
      "    print \"Error while deleting: \" + result",
      "end if"
    ]
  },
  "install": {
    "description": "Installs a program or library from a remote repository listed in `\"/etc/apt/sources.txt\"`. If no path is specified, the program installs in `\"/lib\"` if it is a library or in `\"/bin\"` otherwise. If any of the provided parameters have a type that deviates from the defined signature, the method will return `null`. On success, it will return a `number` with the value one. In case of failure, it will return a `string` containing an error message.",
    "example": [
      "aptClient = include_lib(\"/lib/aptclient.so\")",
      "result = install(aptClient, \"rshell_interface\")",
      "if result == 1 then",
      "    print \"Installed program successful!\"",
      "else",
      "    print \"Error while installing: \" + result",
      "end if"
    ]
  },
  "check_upgrade": {
    "description": "Verifies if there is a newer version of the program or library in the repository. If any of the provided parameters have a type that deviates from the defined signature, the method will return `null`. On success, it will return a `number`, which can be either zero or one. Zero indicates that there is no new version available, while one indicates that there is a new version. In case of failure, it will return a string containing an error message.",
    "example": [
      "aptClient = include_lib(\"/lib/aptclient.so\")",
      "result = check_upgrade(aptClient, \"/bin/rshell_interface\")",
      "if result == 0 then",
      "    print \"Program doesnt need an update!\"",
      "else if result == 1 then",
      "    print \"Program does need an update!\"",
      "else",
      "    print \"Error while checking version: \" + result",
      "end if"
    ]
  },
  "coin_price": {
    "description": "Returns a `number` representing the current unit value of the cryptocurrency. In case of an error, it will return a `string` with the error details. If any of the provided parameters have a type that deviates from the defined signature, the method will return `null`.",
    "example": [
      "blockchain = include_lib(\"/lib/blockchain.so\")",
      "price = coin_price(blockchain, \"test8\")",
      "if typeof(price) == \"string\" then",
      "    exit \"Couldnt get coin price due to: \" + price",
      "end if",
      "print \"Your coin price is \" + price"
    ]
  },
  "show_history": {
    "description": "Returns a `map` with the latest changes in the value of a specific cryptocurrency. The key of the `map` is an index represented by a `number`. The value is a `list`, where index 0 is the historical price of the coin and index 1 is the date when the price change occurred. If any of the provided parameters have a type that deviates from the defined signature, or if no coin exists with this name, the method will return `null`.",
    "example": [
      "blockchain = include_lib(\"/lib/blockchain.so\")",
      "history = show_history(blockchain, \"test\")",
      "if typeof(history) == \"string\" then",
      "    exit \"Couldnt fetch history due to: \" + history",
      "end if",
      "for entry in values(history)",
      "    price = entry[0]",
      "    date = entry[1]",
      "    print \"The price on \" + date + \" was \" + price",
      "end for"
    ]
  },
  "amount_mined": {
    "description": "Returns a `number` representing the total amount of mined coins. In case of an error, it will return a string with details. If any of the provided parameters have a type that deviates from the defined signature, the method will return `null`.",
    "example": [
      "blockchain = include_lib(\"/lib/blockchain.so\")",
      "mined = amount_mined(blockchain, \"test\")",
      "if typeof(mined) == \"string\" then",
      "    exit \"Couldnt get amount mined due to: \" + mined",
      "end if",
      "print \"Your mined amount is \" + mined"
    ]
  },
  "get_coin": {
    "description": "Returns a `coin` object used to manage the currency. In case of an error, it will return a `string` with the details. If any of the provided parameters have a type that deviates from the defined signature, the method will return `null`.",
    "example": [
      "blockchain = include_lib(\"/lib/blockchain.so\")",
      "coin = get_coin(blockchain, \"test\", \"test\", \"test\")",
      "if typeof(coin) != \"coin\" then",
      "    exit \"Couldnt get coin object due to: \" + coin",
      "end if",
      "print \"Your coin address is \" + get_address(coin)"
    ]
  },
  "login_wallet": {
    "description": "Returns a `wallet` object on success. In case of an error, it will return a `string` indicating the reason. If any of the provided parameters have a type that deviates from the defined signature, the method will return `null`.",
    "example": [
      "blockchain = include_lib(\"/lib/blockchain.so\")",
      "wallet = login_wallet(blockchain, \"test\", \"test\")",
      "if typeof(wallet) == \"string\" then",
      "  print \"Login failed due to: \" + wallet",
      "else",
      "  print \"Login was successful!\"",
      "end if"
    ]
  },
  "create_wallet": {
    "description": "Creates a `wallet` and returns a `wallet` object on success, which can be used to manage cryptocurrencies. In case of an error, it will return a `string` with the details. If any of the provided parameters have a type that deviates from the defined signature, the method will return `null`.",
    "example": [
      "blockchain = include_lib(\"/lib/blockchain.so\")",
      "wallet = create_wallet(blockchain, \"test\", \"test\")",
      "if typeof(wallet) == \"string\" then",
      "  print \"Wallet creation failed due to: \" + wallet",
      "else",
      "  print \"Wallet creation was successful!\"",
      "end if"
    ]
  },
  "delete_coin": {
    "description": "Removes a cryptocurrency from the world. It is required to provide the credentials used in the creation of the cryptocurrency. On success, it will return a `number` with the value one. On failure, it will return a `string` containing details. If any of the provided parameters have a type that deviates from the defined signature, the method will return `null`.",
    "example": [
      "blockchain = include_lib(\"/lib/blockchain.so\")",
      "result = delete_coin(blockchain, \"test\", \"test\", \"test\")",
      "if typeof(result) == \"string\" then",
      "    exit \"Couldnt delete coin due to: \" + result",
      "end if",
      "print \"Coin got deleted\""
    ]
  },
  "set_cycle_mining": {
    "description": "Defines the interval (in-game hours) in which each user receives a coin reward when mining. The interval cannot be lower than 1 and not be higher than 2160. If any of the provided parameters have a type that deviates from the defined signature, the method will return `null`. On success, it will return a `number` with the value one. In case of failure, the method will return a `string` with details.",
    "example": [
      "blockchain = include_lib(\"/lib/blockchain.so\")",
      "coin = get_coin(blockchain, \"test\", \"test\", \"test\")",
      "result = set_cycle_mining(coin, 20)",
      "if result == 1 then",
      "    print \"Successful updated mining interval\"",
      "else",
      "    print \"Failed updating mining interval\"",
      "end if"
    ]
  },
  "get_cycle_mining": {
    "description": "Returns a `number` representing the defined interval in which each user receives a coin reward when mining. In case of failure, the method will return a `string` with details. If an invalid coin object is provided, the method will return `null`.",
    "example": [
      "blockchain = include_lib(\"/lib/blockchain.so\")",
      "coin = get_coin(blockchain, \"test\", \"test\", \"test\")",
      "result = get_cycle_mining(coin)",
      "if typeof(result) == \"string\" then",
      "    exit \"Failed getting cyclic mining value due to: \" + result",
      "end if",
      "print \"cyclic mining value: \" + result"
    ]
  },
  "get_reward": {
    "description": "Returns a `number` representing the amount of coins that will be received as a reward after each mining cycle. In case of failure, the method will return a `string` with details. If an invalid coin object is provided, the method will return `null`.",
    "example": [
      "blockchain = include_lib(\"/lib/blockchain.so\")",
      "coin = get_coin(blockchain, \"test\", \"test\", \"test\")",
      "result = get_reward(coin)",
      "if typeof(result) == \"string\" then",
      "    exit \"Failed getting reward value due to: \" + result",
      "end if",
      "print \"reward value: \" + result"
    ]
  },
  "set_reward": {
    "description": "Assigns the reward that miners will receive after each mining cycle. The reward value has to be above one. If any of the provided parameters have a type that deviates from the defined signature, the method will return `null`. On success, the method will return a `number` with the value one. In case of failure, the method will return a `string` with details.",
    "example": [
      "blockchain = include_lib(\"/lib/blockchain.so\")",
      "coin = get_coin(blockchain, \"test\", \"test\", \"test\")",
      "result = set_reward(coin, -1)",
      "if typeof(result) == \"string\" then",
      "    exit \"Failed setting reward due to: \" + result",
      "end if",
      "print \"Successfully set reward!\""
    ]
  },
  "transaction": {
    "description": "Makes a transaction of the currency between the indicated subwallets. In case of an error, a `string` with the details is returned. In case of success, a `number` with a value of one will be returned. If any of the provided parameters have a type that deviates from the defined signature, the method will return `null`.",
    "example": [
      "blockchain = include_lib(\"/lib/blockchain.so\")",
      "coin = get_coin(blockchain, \"test\", \"test\", \"test\")",
      "result = transaction(coin, \"test\", \"test2\", 20)",
      "if typeof(result) == \"string\" then",
      "    exit \"Failed transaction due to: \" + result",
      "end if",
      "print \"Successfully transfered!\""
    ]
  },
  "create_subwallet": {
    "description": "Registers a new account in the `coin` that can be used to manage services such as stores. It is necessary to provide the PIN of the owner's `wallet` that wants to register. In case of success, the method will return a `number` with the value one. If any of the provided parameters have a type that deviates from the defined signature, the method will return `null`. In case of an error, a `string` with the details is returned.",
    "example": [
      "blockchain = include_lib(\"/lib/blockchain.so\")",
      "coin = get_coin(blockchain, \"test\", \"test\", \"test\")",
      "wallet = login_wallet(blockchain, \"test\", \"test\")",
      "result = create_subwallet(coin, \"test\", wallet.get_pin, \"test\", \"test\")",
      "if typeof(result) == \"string\" then",
      "    exit \"Failed to create subwallet due to: \" + result",
      "end if",
      "print \"Successfully created subwallet!\""
    ]
  },
  "get_subwallet": {
    "description": "Returns a `subWallet` object on success. In case of error, it returns a `string` with the details. If any of the provided parameters have a type that deviates from the defined signature, the method will return `null`.",
    "example": [
      "blockchain = include_lib(\"/lib/blockchain.so\")",
      "coin = get_coin(blockchain, \"test\", \"test\", \"test\")",
      "result = get_subwallet(coin, \"test\")",
      "if typeof(result) == \"string\" then",
      "    exit \"Failed to get subwallet due to: \" + result",
      "end if",
      "print \"Successfully received subwallet!\""
    ]
  },
  "get_subwallets": {
    "description": "Returns a `list` where each item is a `subWallet` object, including all the accounts registered in the cryptocurrency. In case of error, it returns a `string` with the details. If an invalid coin object is provided, the method will return `null`.",
    "example": [
      "blockchain = include_lib(\"/lib/blockchain.so\")",
      "coin = get_coin(blockchain, \"test\", \"test\", \"test\")",
      "result = get_subwallets(coin)",
      "if typeof(result) == \"string\" then",
      "    exit \"Failed to get subwallets due to: \" + result",
      "end if",
      "for subwallet in result",
      "    print get_user(subwallet) + \" has \" + get_balance_subwallet(subwallet) + \" coins\"",
      "end for"
    ]
  },
  "set_address": {
    "description": "Configures a valid address that will be shown to users who do not have the currency, indicating where to register. In case of an error, a `string` with the details is returned. In case of success, a `number` with a value of one will be returned. If any of the provided parameters have a type that deviates from the defined signature, the method will return `null`.",
    "example": [
      "blockchain = include_lib(\"/lib/blockchain.so\")",
      "coin = get_coin(blockchain, \"test\", \"test\", \"test\")",
      "result = set_address(coin, \"12.12.12.12\")",
      "if typeof(result) == \"string\" then",
      "    exit \"Failed to set address due to: \" + result",
      "end if",
      "print \"Successfully set address!\""
    ]
  },
  "get_address": {
    "description": "Returns the configured address that will be shown to users who do not have the currency, indicating where they have to register. In case of an error, the method will return a `string` with details. If an invalid coin object is provided, the method will return `null`.",
    "example": [
      "blockchain = include_lib(\"/lib/blockchain.so\")",
      "coin = get_coin(blockchain, \"test\", \"test\", \"test\")",
      "result = get_address(coin)",
      "if not is_valid_ip(result) then",
      "    exit \"Failed to get address due to: \" + result",
      "end if",
      "print \"address: \" + result"
    ]
  },
  "get_mined_coins": {
    "description": "Returns a `number` representing the amount of coins that have been mined so far. In case of an error, the method will return a `string` with details. If an invalid coin object is provided, the method will return `null`.",
    "example": [
      "blockchain = include_lib(\"/lib/blockchain.so\")",
      "coin = get_coin(blockchain, \"test\", \"test\", \"test\")",
      "result = get_mined_coins(coin)",
      "if typeof(result) == \"string\" then",
      "    exit \"Failed to get mined coins due to: \" + result",
      "end if",
      "print \"mined coins: \" + result"
    ]
  },
  "reset_password_coin": {
    "description": "Resets the password of the coin. It returns a `number` with the value one if resetting was successful; otherwise, it will return a `string`. If an invalid coin object is provided, the method will return `null`.",
    "example": [
      "blockchain = include_lib(\"/lib/blockchain.so\")",
      "coin = get_coin(blockchain, \"test\", \"test\", \"test\")",
      "result = reset_password(coin, \"test\")",
      "if typeof(result) == \"string\" then",
      "    exit \"Failed to reset password due to: \" + result",
      "end if",
      "print \"Successfully reset password\""
    ]
  },
  "get_ports": {
    "description": "Returns a `list` of `port`s on the `computer` which are active. If an invalid `computer` object is passed, this method will return `null`.",
    "example": [
      "router = get_router",
      "ports = get_ports(host_computer(get_shell))",
      "for port in ports",
      "    print(\"Info: \" + router.port_info(port))",
      "end for"
    ]
  },
  "get_name": {
    "description": "Returns the hostname of the machine. If an invalid `computer` object is passed, this method will return a `string` containing `\"Unknown\"`.",
    "example": [
      "computerName = get_name(host_computer(get_shell))",
      "print(\"The name of your machine is \" + computerName)"
    ]
  },
  "lan_ip": {
    "description": "Returns a `string` with the local IP address of the `computer`. If an invalid `computer` object is passed, this method will return `null`.",
    "example": [
      "localIp = lan_ip(host_computer(get_shell))",
      "print(\"Public ip:\" + localIp)"
    ]
  },
  "public_ip_pc": {
    "description": "Returns a `string` with the public IP address of the `computer`. If an invalid `computer` object is passed, this method will return `null`.",
    "example": [
      "publicIp = public_ip_pc(host_computer(get_shell))",
      "print(\"Public ip:\" + publicIp)"
    ]
  },
  "File": {
    "description": "Returns a `file` located at the path provided in the arguments. The path can be either relative or absolute. Keep in mind that any `file` object can be a folder as well. If the provided path cannot be resolved, meaning that no file or folder exists, this method will return `null`. Providing any other type than `string` or the value being empty for the path will result in an error thrown interrupting the script execution. If an invalid `computer` object is passed, this method will return `null`.",
    "example": [
      "filePath = \"/etc/passwd\"",
      "file = File(host_computer(get_shell), filePath)",
      "if file != null then",
      "   print(file.get_content)",
      "else",
      "   print(\"File at given path \" + filePath + \" does not exist.\")",
      "end if"
    ]
  },
  "create_folder": {
    "description": "Creates a folder at the path provided in the arguments. There are certain limitations when it comes to creating a folder. The folder name has to be alphanumeric and below 128 characters. Creation will fail as well when there is already a folder in place or if there are lacking permissions. Additionally, there is a folder limit of about 250 in each folder and 3125 folders in the computer overall. In case the folder creation fails, the method will return a `string` with details. In case of success, it will return a `number` with the value one. Providing any type that deviates from the signature or using this method in an SSH encryption process will cause an error to be thrown, aborting further script execution. If an invalid `computer` object is passed, this method will return `null`.",
    "example": [
      "path = \"/home/\" + active_user + \"/Desktop\"",
      "computer = host_computer(get_shell)",
      "createResult = create_folder(computer, path, \"myfolder\")",
      "if typeof(createResult) == \"string\" then",
      "   print(\"There was an error when creating the folder: \" + createResult)",
      "else",
      "   print(\"Folder got created at given path \" + path)",
      "end if"
    ]
  },
  "is_network_active": {
    "description": "Returns a `number` with either the value one or zero. The value will be one if the `computer` has internet access. If there is no internet access, it will return zero instead. In case an invalid `computer` object is passed, this method will return `null`.",
    "example": [
      "computer = host_computer(get_shell)",
      "if is_network_active(computer) then",
      "   print(\"You're connected.\")",
      "else",
      "   print(\"You're not connected.\")",
      "end if"
    ]
  },
  "touch": {
    "description": "Creates an empty text `file` at the provided path. Certain limitations apply to file creation: the `file` name must be alphanumeric and below 128 characters. Creation will fail if a `file` already exists at the specified path or if there are insufficient permissions. Additionally, there is a file limit of about 250 per folder and 3125 files overall on the computer. If successful, it returns a `number` with the value one. On failure, it returns a `string` with details. Using this method in an SSH encryption process will cause an error to be thrown, preventing further script execution. If an invalid `computer` object is passed, this method will return `null`.",
    "example": [
      "path = \"/home/\" + active_user + \"/Desktop\"",
      "computer = host_computer(get_shell)",
      "createResult = touch(computer, path, \"myFile.txt\")",
      "if typeof(createResult) == \"string\" then",
      "   print(\"There was an error when creating the file: \" + createResult)",
      "else",
      "   print(\"File got created at given path \" + path)",
      "end if"
    ]
  },
  "show_procs": {
    "description": "Returns a `string` providing an overview of all active processes on the `computer`. This includes information about the username, PID, CPU usage, memory consumption, and command name. Using this method in an SSH encryption process will throw an error, preventing further script execution. If an invalid `computer` object is passed, this method will return `null`.",
    "example": [
      "computer = host_computer(get_shell)",
      "procs = show_procs(computer)",
      "list = procs.split(char(10))[1:]",
      "processes = []",
      "for item in list",
      "   parsedItem = item.split(\" \")",
      "   process = {}",
      "   process.user = parsedItem[0]",
      "   process.pid = parsedItem[1]",
      "   process.cpu = parsedItem[2]",
      "   process.mem = parsedItem[3]",
      "   process.command = parsedItem[4]",
      "   processes.push(process)",
      "end for",
      "print(processes)"
    ]
  },
  "network_devices": {
    "description": "Returns a `string` containing all network devices available on the `computer`, with each item providing information about the interface name, chipset, and whether monitoring support is enabled. If an invalid `computer` object is passed, this method will return `null`.",
    "example": [
      "computer = host_computer(get_shell)",
      "devices = network_devices(computer)",
      "deviceList = devices.split(char(10))",
      "for item in deviceList",
      "   print(item)",
      "end for"
    ]
  },
  "change_password": {
    "description": "Changes the password of an existing user on the `computer`. Root permissions are necessary for successful password changes. Passwords can only include alphanumeric characters and cannot exceed 15 characters. If the password change fails, this method will return a `string` containing information on why it failed. If the change succeeds, it will return a `number` with the value one. If the provided username is empty, an error will be thrown, preventing any further script execution. If any of the provided parameters have a type that deviates from the defined signature, the method will return `null`.",
    "example": [
      "computer = host_computer(get_shell(\"root\", \"test\"))",
      "changeResult = change_password(computer, \"test\", \"newPassword\")",
      "if typeof(changeResult) == \"string\" then",
      "   print(\"There was an error when changing the password: \" + changeResult)",
      "else",
      "   print(\"Password got successfully changed.\")",
      "end if"
    ]
  },
  "create_user": {
    "description": "Creates a user on the `computer`, with the specified name and password. Root permissions are necessary for successful user creation. Neither username nor password can exceed more than 15 characters and both need to be alphanumeric. There cannot be more than 15 users created on the same `computer`. In case the creation fails, this method will return a `string` containing the reason for the failure. On success, it will return a `number` with the value one. If the provided username is empty or either of the values exceeds 15 characters, an error will be thrown, interrupting further script execution. If any of the provided parameters have a type that deviates from the defined signature, the method will return `null`.",
    "example": [
      "computer = host_computer(get_shell(\"root\", \"test\"))",
      "creationResult = create_user(computer, \"newUser\", \"123\")",
      "if typeof(creationResult) == \"string\" then",
      "   print(\"There was an error when creating an user: \" + creationResult)",
      "else",
      "   print(\"User got successfully created.\")",
      "end if"
    ]
  },
  "delete_user": {
    "description": "Deletes the indicated user from the `computer`. It can optionally also delete the home folder related to the user. By default, the home folder will not be deleted. Root permissions are necessary to successfully delete a user. Keep in mind that you cannot delete the root user. In case the deletion fails, this method will return a `string` containing the cause of failure. On success, this method will return a `number` with the value one. If the provided username is empty, an error will be thrown, interrupting further script execution. If any of the provided parameters have a type that deviates from the defined signature, the method will return `null`.",
    "example": [
      "computer = host_computer(get_shell(\"root\", \"test\"))",
      "deletionResult = delete_user(computer, \"test\", true)",
      "if typeof(deletionResult) == \"string\" then",
      "   print(\"There was an error when deleting an user: \" + deletionResult)",
      "else",
      "   print(\"User got successfully deleted.\")",
      "end if"
    ]
  },
  "create_group": {
    "description": "Creates a new group associated with an existing user on the `computer`. It is necessary to be root to be able to successfully create a group. There are a few limitations when creating a group such as a character limit of 15 and that the group name may only contain alphanumeric characters. In case the group creation fails, this method will return a `string` containing the cause of failure. On success, it will return a `number` with the value one. In case the provided arguments are empty or the username exceeds 15 characters, an error will be thrown, interrupting further script execution. If any of the provided parameters have a type that deviates from the defined signature, the method will return `null`.",
    "example": [
      "computer = host_computer(get_shell(\"root\", \"test\"))",
      "creationResult = create_group(computer, \"test\", \"staff\")",
      "if typeof(creationResult) == \"string\" then",
      "   print(\"There was an error when creating a group: \" + creationResult)",
      "else",
      "   print(\"Group got successfully created.\")",
      "end if"
    ]
  },
  "delete_group": {
    "description": "Deletes an existing group associated with an existing user on the `computer`. It is necessary to be root to be able to successfully delete a group. In case the group deletion fails, this method will return a `string` containing the cause of failure. On success, it will return `number` with the value one. If either of the provided values is empty, an error will be thrown preventing further script execution. If any of the provided parameters have a type that deviates from the defined signature, the method will return `null`.",
    "example": [
      "computer = host_computer(get_shell(\"root\", \"test\"))",
      "deletionResult = delete_group(computer, \"test\", \"staff\")",
      "if typeof(deletionResult) == \"string\" then",
      "   print(\"There was an error when deleting a group: \" + deletionResult)",
      "else",
      "   print(\"Group got successfully deleted.\")",
      "end if"
    ]
  },
  "groups": {
    "description": "Returns a `string` containing groups associated with an existing user on the `computer`. In case the user does not exist, a `string` will be returned with an error message. If the provided username is empty, an error will be thrown preventing further script execution. If any of the provided parameters have a type that deviates from the defined signature, the method will return `null`.",
    "example": [
      "computer = host_computer(get_shell(\"root\", \"test\"))",
      "create_group(computer, \"root\", \"staff\")",
      "groups = groups(computer, \"root\")",
      "listOfGroups = groups.split(char(10))",
      "print(listOfGroups)"
    ]
  },
  "close_program": {
    "description": "Closes a program associated with the provided PID. You can see the list of active programs by either using `show_procs` or typing `ps` into your terminal. To close a program, you need to be either the owner of the running process or root. In case the closing of a program fails, this method will return a `string` containing details. On success, it will return a `number` with the value one. If there is no process with the provided PID, this method will return a `number` with the value zero. If any of the provided parameters have a type that deviates from the defined signature, the method will return `null`.",
    "example": [
      "computer = host_computer(get_shell(\"root\", \"test\"))",
      "processes = split(show_procs(computer), char(10))[1:]",
      "pid = split(processes[1], \" \")[1]",
      "closeResult = close_program(computer, to_int(pid))",
      "if typeof(closeResult) == \"string\" then",
      "   print(\"There was an error when closing a program: \" + closeResult)",
      "else",
      "   print(\"Program with pid \" + pid + \" got successfully closed.\")",
      "end if"
    ]
  },
  "wifi_networks": {
    "description": "Returns a list of the Wi-Fi networks that are available for the provided interface. Each item in the `list` is a `string` containing information on the BSSID, PWR, and ESSID. If no matching netDevice can be found or an invalid `computer` object is passed, this method will return `null`. In case the active network card is not a Wi-Fi card, an error will be thrown, preventing any further script execution.",
    "example": [
      "computer = host_computer(get_shell(\"root\", \"test\"))",
      "networks = wifi_networks(computer, \"wlan0\")",
      "result = []",
      "for network in networks",
      "   parsedItem = network.split(\" \")",
      "   item = {}",
      "   item.BSSID = parsedItem[0]",
      "   item.PWR = parsedItem[1]",
      "   item.ESSID = parsedItem[2]",
      "   result.push(item)",
      "end for",
      "print(result)"
    ]
  },
  "connect_wifi": {
    "description": "Connects to the indicated Wi-Fi network. It is not possible to connect to a new Wi-Fi while being logged in as a guest. If connecting to a new Wi-Fi fails, this method will return a `string` containing details. On success, it will return a `number` with the value one. Wi-Fi networks can be found via `wifi_networks` or by typing `iwlist` as a command in the terminal. If any of the provided parameters have a type that deviates from the defined signature, the method will return `null`.",
    "example": [
      "computer = host_computer(get_shell)",
      "networks = wifi_networks(computer)",
      "firstNetwork = networks[0].split(\" \")",
      "BSSID = firstNetwork[0]",
      "ESSID = firstNetwork[2]",
      "connectionResult = connect_wifi(host_computer, \"wlan0\", BSSID, ESSID, \"wifi-password\")",
      "if typeof(connectionResult) == \"string\" then",
      "   print(\"There was an error while connecting to new Wifi: \" + connectionResult)",
      "else",
      "   print(\"Connected to new Wifi successfully.\")",
      "end if"
    ]
  },
  "connect_ethernet": {
    "description": "Sets up a new IP address on the `computer` through the ethernet connection. It is not possible to set up a new IP address while being logged in as a guest. On failure, this method will either return a `string` with details or `null`. On success, it will return an empty `string`. If any of the provided parameters have a type that deviates from the defined signature or the computer is not connected to the internet, an error will be thrown preventing any further script execution.",
    "example": [
      "computer = host_computer(get_shell)",
      "connectionResult = connect_ethernet(computer, \"eth0\", \"192.168.0.4\", local_ip(get_router))",
      "if typeof(connectionResult) == \"string\" then",
      "   print(\"There was an error while connecting: \" + connectionResult)",
      "else",
      "   print(\"Connected successfully.\")",
      "end if"
    ]
  },
  "network_gateway": {
    "description": "Returns a `string` with the gateway IP address configured on the `computer`. If an invalid `computer` object gets passed, this method returns a `string` with the value `\"0.0.0.0\"`.",
    "example": [
      "computer = host_computer(get_shell)",
      "gatewayIp = network_gateway(computer)",
      "print(\"Gateway IP: \" + gatewayIp)"
    ]
  },
  "active_net_card": {
    "description": "Returns a `string` which contains either the keyword `\"WIFI\"` or `\"ETHERNET\"` depending on which connection type your `computer` is connected by. In case an invalid `computer` object gets passed, this method will return `null`.",
    "example": [
      "computer = host_computer(get_shell)",
      "netCard = active_net_card(computer)",
      "print(\"Connected by: \" + netCard)"
    ]
  },
  "aircrack": {
    "description": "Returns a `string` containing the password based on the file which was generated via aireplay. In case of failure, it will return `null` instead. If the provided path is empty, an error will be thrown, interrupting the script execution.",
    "example": [
      "crypto = include_lib(\"/lib/crypto.so\")",
      "networks = wifi_networks(host_computer(get_shell), \"wlan0\")",
      "firstNetwork = networks[1].split(\" \")",
      "bssid = firstNetwork[0]",
      "pwr = firstNetwork[1][:-1].to_int",
      "essid = firstNetwork[2]",
      "aireplayResult = aireplay(crypto, bssid, essid, 300000 / pwr)",
      "if (aireplayResult == null) then",
      "   result = aircrack(crypto, home_dir + \"/file.cap\")",
      "   print(result)",
      "end if"
    ]
  },
  "airmon": {
    "description": "Enables or disables the monitor mode of a network device. The `options` parameter can only be `\"start\"` or `\"stop\"`. Monitor mode can only be enabled on Wifi cards. If it wasn't possible to enable or disable the monitor mode, this method will return either a `number` with the value zero or a `string` with details. In case of success, it will return a `number` with the value one.",
    "example": [
      "crypto = include_lib(\"/lib/crypto.so\")",
      "airmonResult = airmon(crypto, \"start\", \"wlan0\")",
      "if typeof(airmonResult) == \"string\" then",
      "   print(\"There was an error while switching monitoring mode: \" + airmonResult)",
      "else",
      "   print(\"Monitoring mode switched successfully.\")",
      "end if"
    ]
  },
  "aireplay": {
    "description": "Used to inject frames on wireless interfaces. Once the command with `\"Control+C\"` is stopped, it will save the captured information in a text file called `\"file.cap\"` in the path where the terminal is currently located. Alternatively, a maximum of captured `acks` can be specified for the command to stop automatically, saving the `\"file.cap\"` file as described above. To figure out how many ACKs are required, you can use the following formula: `\"300000 / [Wifi PWR]\"`. If there is an error, a `string` will be returned with the message indicating the problem. On success, it will return `null`. It is advised though to verify that the capture file actually exists. If the passed `crypto` object is invalid, it will return `null` as well. In case any of the provided values deviate from the signature types or bssid/essid is empty, an error will be thrown preventing any further script execution.",
    "example": [
      "crypto = include_lib(\"/lib/crypto.so\")",
      "networks = wifi_networks(host_computer(get_shell), \"wlan0\")",
      "for index in range(0, networks.len - 1)",
      "   print(index + \".) \" + networks[index])",
      "end for",
      "selectedIndex = user_input(\"Select Wifi: \").to_int",
      "if (typeof(selectedIndex) == \"string\" or selectedIndex < 0 or selectedIndex > networks.len - 1) then",
      "   exit(\"Wrong index!\")",
      "end if",
      "parsed = networks[selectedIndex].split(\" \")",
      "bssid = parsed[0]",
      "pwr = parsed[1][:-1].to_int",
      "essid = parsed[2]",
      "potentialAcks = 300000 / pwr",
      "aireplaycrypto, bssid, essid, potentialAcks)",
      "wifiPassword = aircrack(crypto, \"/home/\" + active_user + \"/file.cap\")",
      "print(\"Wifi password for \" + essid + \" is \" + wifiPassword)"
    ]
  },
  "decipher": {
    "description": "Returns a decrypted password via the provided password MD5 hash. Keep in mind that this method is not decrypting a password but rather checking for existing passwords within the game world with a matching MD5 hash. So in case a password does not exist in the game world, the decryption will fail. On failure, this method will return `null`. Using this method in an SSH encryption process will cause an error to be thrown, aborting further script execution.",
    "example": [
      "crypto = include_lib(\"/lib/crypto.so\")",
      "computer = host_computer(get_shell(\"root\", \"test\"))",
      "passwdContent = get_content(File(computer, \"/etc/passwd\"))",
      "firstAccount = passwdContent.split(char(10))[0]",
      "parsed = firstAccount.split(\":\")",
      "username = parsed[0]",
      "passwordHash = parsed[1]",
      "password = decipher(crypto, passwordHash)",
      "print(\"User: \" + username)",
      "print(\"Password: \" + password)"
    ]
  },
  "smtp_user_list": {
    "description": "Returns a `list` of the existing users on the `computer` where the SMTP service is running. If these users also have an email account registered on the `SMTP` server, it will be indicated in the `list`. SMTP services are usually running on port `25`. In case of failure, this method will return a `string` containing the cause. If any of the provided values deviate from the signature types, this method will return `null`.",
    "example": [
      "crypto = include_lib(\"/lib/crypto.so\")",
      "print(smtp_user_list(crypto, \"192.168.0.4\", 25))"
    ]
  },
  "get_description": {
    "description": "Returns a `string` with the CTF event description. If the provided `ctfEvent` object is invalid or missing, this method will return `null`."
  },
  "get_template": {
    "description": "Returns a `string` with the CTF event template. If the provided `ctfEvent` object is invalid or missing, this method will return `null`."
  },
  "player_success": {
    "description": "Returns a `number` with the value one if the CTF event was completed successfully. Otherwise, this method will return a `number` with the value zero. If the provided `ctfEvent` object is invalid or missing, this method will return `null`."
  },
  "get_creator_name": {
    "description": "Returns a `string` with the name of the CTF event creator. If the provided `ctfEvent` object is invalid or missing, this method will return `null`."
  },
  "get_mail_content": {
    "description": "Returns a `string` with the mail content of the CTF event. If the provided `ctfEvent` object is invalid or missing, this method will return `null`."
  },
  "chmod": {
    "description": "Modifies the `file` permissions. Optionally, these permissions can also be applied recursively. The format for applying permissions is as follows: `\"[references][operator][modes]\"`. The references type is defined through three possible types: user `\"u\"`, group `\"g\"`, and other `\"o\"`. The operator is used to define if permissions get added `\"+\"` or removed `\"-\"`. There are three different modes that can be modified: read `\"r\"`, write `\"w\"`, and execute `\"x\"`. So, for example, `\"o-wrx\"` would remove all possible permissions for others. To add all permissions for others again, `\"o+wrx\"` would be used. In case the modification fails, this method will return a `string` containing information about the reason. Otherwise, an empty `string` is returned. In case any type other than `number` is used for the `isRecursive` parameter, an error will be thrown preventing further script execution. If an invalid `file` object is passed, this method will return `null`.",
    "example": [
      "hostComputer = host_computer(get_shell(\"root\", \"test\"))",
      "rootFolder = File(hostComputer, \"/bin\")",
      "oldPermissions = permissions(rootFolder)",
      "chmod(rootFolder, \"o-wrx\", true)",
      "newPermissions = permissions(rootFolder)",
      "print(\"Old permissions: \" + oldPermissions)",
      "print(\"New permissions: \" + newPermissions)"
    ]
  },
  "copy": {
    "description": "Copies the `file` to the provided path. Files can only be copied if the user has read and write permissions or is root. The new filename has to be below 128 characters and alphanumeric. After success, this method will return a `number` with the value one. Otherwise, it will return a `string` containing information about the reason for failure. If any of the parameter types deviate from the method signature, this method is used within an SSH encryption process, the new name exceeds 128 characters, or the path is too long, an error will be thrown, causing an interruption of script execution. In case the current file gets deleted or an invalid `file` object is passed, this method will return `null`.",
    "example": [
      "computer = host_computer(get_shell(\"root\", \"test\"))",
      "passwdFile = File(computer, \"/etc/passwd\")",
      "copyResult = copy(passwdFile, \"/etc/\", \"duplicate\")",
      "if typeof(copyResult) == \"string\" then",
      "   print(\"There was an error while copying file: \" + copyResult)",
      "else",
      "   print(\"File got copied successfully.\")",
      "end if"
    ]
  },
  "move": {
    "description": "Moves the `file` to the provided path. Files can only be moved if the user has read and write permissions or is root. The new filename has to be below 128 characters and alphanumeric. After success, this method will return a `number` with the value one. Otherwise, this method will return a `string` with details. If any of the parameter types deviate from the method signature, this method is used within an SSH encryption process, the new name exceeds 128 characters, or the path is too long, an error will be thrown, causing an interruption of script execution. In case the current file gets deleted or an invalid `file` object is passed, this method will return `null`.",
    "example": [
      "computer = host_computer(get_shell(\"root\", \"test\"))",
      "passwdFile = File(computer, \"/etc/passwd\")",
      "moveResult = move(passwdFile, \"/etc/\", \"/moved/\")",
      "if typeof(moveResult) == \"string\" then",
      "   print(\"There was an error while moving file: \" + moveResult)",
      "else",
      "   print(\"File got moved successfully.\")",
      "end if"
    ]
  },
  "rename": {
    "description": "Rename the file with the name provided. Files can only be renamed if the user has write permissions or is root. The new filename has to be below 128 characters and alphanumeric. On failure, this method will return a `string` with details. Otherwise, this method will return an empty string. If this method is used within an SSH encryption process, an error will be thrown, causing the script execution to be interrupted. In case the provided name is `null` or an invalid `file` object is passed, this method will return a `number` with the value zero.",
    "example": [
      "computer = host_computer(get_shell(\"root\", \"test\"))",
      "passwdFile = File(computer, \"/etc/passwd\")",
      "renameResult = rename(passwdFile, \"renamed\")",
      "if typeof(renameResult) == \"string\" then",
      "   print(\"There was an error while renaming file: \" + renameResult)",
      "else",
      "   print(\"File got renamed successfully.\")",
      "end if"
    ]
  },
  "path": {
    "description": "Returns a `string` with the path of the file. In case the file gets deleted, it will still return its path prior to deletion. If an invalid `file` object is passed, this method will return `null`.",
    "example": [
      "computer = host_computer(get_shell)",
      "passwdFile = File(computer, \"/etc/passwd\")",
      "print(\"File location: \" + path(passwdFile))"
    ]
  },
  "is_folder": {
    "description": "Returns a `number`. The value is one if the file is a folder, zero otherwise. In case the file gets deleted or an invalid `file` object is passed, this method will return `null` instead.",
    "example": [
      "computer = host_computer(get_shell)",
      "etcFolder = File(computer, \"/etc\")",
      "print(\"Is a folder: \" + is_folder(etcFolder))"
    ]
  },
  "parent": {
    "description": "Returns the parent folder of the current file or folder. In case there is no parent folder `null` will be returned instead. In case the file gets deleted or an invalid `file` object gets passed, this method will return `null` as well.",
    "example": [
      "computer = host_computer(get_shell)",
      "etcFolder = File(computer, \"/etc\")",
      "print(\"Parent path: \" + path(parent(etcFolder)))"
    ]
  },
  "name": {
    "description": "Returns a `string` with the name of the file. In case the file gets deleted or an invalid `file` object gets passed, this method will return `null` instead.",
    "example": [
      "computer = host_computer(get_shell)",
      "passwdFile = File(computer, \"/etc/passwd\")",
      "print(\"Filename: \" + name(passwdFile))"
    ]
  },
  "allow_import": {
    "description": "Returns a `number`. If the file is binary and can be imported by other scripts, the value will be one; otherwise, the value will be zero. In case the file gets deleted, this method will cause a crash. If an invalid `file` object gets passed, this method will return `null` instead.",
    "example": [
      "computer = host_computer(get_shell)",
      "lsBinary = File(computer, \"/bin/ls\")",
      "print(\"File can be imported: \" + allow_import(lsBinary))"
    ]
  },
  "get_content": {
    "description": "Returns a `string` representing the content of the file. To read a file, the user requires read access or being root. Note that you cannot read a binary file. In case of failure, `null` will be returned. If this method is used within an SSH encryption process, an error will be thrown, preventing any further script execution.",
    "example": [
      "computer = host_computer(get_shell(\"root\", \"test\"))",
      "passwdFile = File(computer, \"/etc/passwd\")",
      "print(\"File content: \" + get_content(passwdFile))"
    ]
  },
  "set_content": {
    "description": "Saves text into a `file`. The content will not get appended to the `file`; therefore, existing content will be overridden. To set new content, the user requires write permissions or being root. Keep in mind that text files cannot exceed the character limit of 160,000. In case setting the content was successful, a `number` with the value one will be returned. Otherwise, a `string` with details will be returned. If this method is used within an SSH encryption process, an error will be thrown, preventing any further script execution. If the provided content is `null`, this method will return a `number` with the value zero. In case the file gets deleted this method will return `null`. In case an invalid `file` object gets passed this method will return a `number` with the value zero.",
    "example": [
      "computer = host_computer(get_shell(\"root\", \"test\"))",
      "passwdFile = File(computer, \"/etc/passwd\")",
      "setResult = set_content(passwdFile, \"moo\")",
      "if typeof(setResult) == \"string\" then",
      "   print(\"There was an error while setting file content: \" + setResult)",
      "else",
      "   print(\"File content got changed successfully.\")",
      "end if"
    ]
  },
  "is_binary": {
    "description": "Returns a `number`. If the file is binary, the value will be one; otherwise, it will be zero. In case the file gets deleted or an invalid `file` object gets passed, this method will return `null` instead.",
    "example": [
      "computer = host_computer(get_shell)",
      "lsBinary = File(computer, \"/bin/ls\")",
      "print(\"File is a binary: \" + is_binary(lsBinary))"
    ]
  },
  "has_permission": {
    "description": "Returns a `number` indicating if the user who launched the script has the requested permissions. One will indicate that the user has the correct permissions. In case permissions are lacking, the value will be zero. There are three different permission types: read `\"r\"`, write `\"w\"`, and execute `\"x\"`. In case the file gets deleted or an invalid `file` object gets passed, this method will return `null` instead.",
    "example": [
      "computer = host_computer(get_shell)",
      "lsBinary = File(computer, \"/bin/ls\")",
      "print(\"Is able to execute ls: \" + has_permission(lsBinary, \"x\"))"
    ]
  },
  "delete": {
    "description": "Delete the current file. To delete files, write permissions are required or being root. In case of failure, a `string` with details will be returned. Otherwise, an empty `string` gets returned. Please note that deleting a file will leave a log entry. In case an invalid `file` object gets passed, this method will return `null`.",
    "example": [
      "computer = host_computer(get_shell)",
      "lsBinary = File(computer, \"/bin/ls\")",
      "deletionResult = delete(lsBinary)",
      "if typeof(deletionResult) == \"string\" and len(deletionResult) > 0 then",
      "   print(\"There was an error while deleting a file: \" + deletionResult)",
      "else",
      "   print(\"File got deleted successfully.\")",
      "end if"
    ]
  },
  "get_folders": {
    "description": "Returns a `list` of folders. In case the current entity is a file instead of a folder this method will return `null`, so it is advisable to first use the `is_folder` function before calling this method. In case the current folder gets deleted or an invalid `file` object gets passed, this method will return `null` as well.",
    "example": [
      "computer = host_computer(get_shell)",
      "binFolder = File(computer, \"/home\")",
      "folders = get_folders(binFolder)",
      "for folder in folders",
      "   print(folder.path)",
      "end for"
    ]
  },
  "get_files": {
    "description": "Returns a `list` of files. In case the current entity is a file instead of a folder this method will return `null`, so it is advisable to first use the `is_folder` function before calling this method. In case the current folder gets deleted or an invalid `file` object gets passed, this method will return `null` as well.",
    "example": [
      "computer = host_computer(get_shell)",
      "binFolder = File(computer, \"/bin\")",
      "files = get_files(binFolder)",
      "for file in files",
      "   print(file.path)",
      "end for"
    ]
  },
  "permissions": {
    "description": "Returns a `string` with the current file permissions. In case the current file gets deleted or an invalid `file` object gets passed, this method will return `null`. The format for this permissions `string` is as follows: `\"[fileType][wrx](u)[wrx](g)[wrx](o)\"`. The file type is either `\"d\"` in case it's a directory or `\"-\"`. The user type gets defined through three possible types: user `\"u\"`, group `\"g\"`, and other `\"o\"`. There are three different permission types: read `\"r\"`, write `\"w\"`, and execute `\"x\"`. An example of a `string` returned by this method would be `\"-rwxr-xr-x\"`. Taking the latter as an example, the following things become clear:\n* The provided file is not a directory.\n* The user has full access.\n* The group and others have almost all permissions besides writing.\n",
    "example": [
      "computer = host_computer(get_shell)",
      "binFolder = File(computer, \"/bin\")",
      "perms = permissions(binFolder)",
      "fileType = perms[0]",
      "permissionsForUser = perms[1:4]",
      "permissionsForGroup = perms[4:7]",
      "permissionsForOther = perms[7:10]",
      "print(\"File type: \" + fileType)",
      "print(\"User permissions: \" + permissionsForUser)",
      "print(\"Group permissions: \" + permissionsForGroup)",
      "print(\"Other permissions: \" + permissionsForOther)"
    ]
  },
  "owner": {
    "description": "Returns a `string` with the name of the file owner. User permissions get applied to whoever is the owner of a file. In case the current file gets deleted or an invalid `file` object gets passed, this method will return `null`.",
    "example": [
      "computer = host_computer(get_shell)",
      "lsBinary = File(computer, \"/bin/ls\")",
      "print(\"Owner of ls is: \" + owner(lsBinary))"
    ]
  },
  "set_owner": {
    "description": "Change the owner of this file. Optionally the owner can get applied recursively. The owner's name cannot exceed 15 characters. Additionally either write permissions or being root is required. In case of failure a `string` gets returned containing the cause. Otherwise an empty `string` gets returned. In case the current file gets deleted, an invalid `file` object gets passed or the passed owner value is not a `string`, this method will return `null`. If the passed owner value is empty, the owner value is longer than 15 characters, or the passed recursive value deviates from its original type, an error will be thrown, interrupting further script execution.",
    "example": [
      "computer = host_computer(get_shell)",
      "lsBinary = File(computer, \"/bin/ls\")",
      "ownerResult = set_owner(lsBinary, \"root\")",
      "if typeof(ownerResult) == \"string\" then",
      "   print(\"There was an error while changing owner: \" + ownerResult)",
      "else",
      "   print(\"File owner changed successfully.\")",
      "end if"
    ]
  },
  "group": {
    "description": "Returns a `string` with the name of the group to which this file belongs. Group permissions get applied to whoever is the owner of a file. In case the current file gets deleted or an invalid `file` object gets passed, this method will return `null`.",
    "example": [
      "computer = host_computer(get_shell)",
      "lsBinary = File(computer, \"/bin/ls\")",
      "print(\"File is related to following group: \" + group(lsBinary))"
    ]
  },
  "set_group": {
    "description": "Change the group related to this file. Optionally the group can get applied recursively. The group name cannot exceed 15 characters. Additionally either write permissions or being root is required. In case of failure, a `string` with details. On success, an empty `string` gets returned. In case the current file gets deleted, an invalid `file` object gets passed or the passed group is not a `string`, this method will return `null`. If the passed group value is empty, the group value is longer than 15 characters, or the passed recursive value deviates from its original type, an error will be thrown, preventing further script execution.",
    "example": [
      "computer = host_computer(get_shell)",
      "lsBinary = File(computer, \"/bin/ls\")",
      "ownerResult = set_group(lsBinary, \"root\")",
      "if typeof(ownerResult) == \"string\" then",
      "   print(\"There was an error while changing group: \" + ownerResult)",
      "else",
      "   print(\"File group changed successfully.\")",
      "end if"
    ]
  },
  "size": {
    "description": "Returns a `string` with the size of the file in bytes. There is no correlation between file size and actual file content. Instead, the file size is depending on the name of the file. In case the current file gets deleted or an invalid `file` object gets passed, this method will return `null`.",
    "example": [
      "computer = host_computer(get_shell)",
      "lsBinary = File(computer, \"/bin/ls\")",
      "size = size(lsBinary)",
      "if size.to_int > 1000 then",
      "   print(\"File size is bigger than 1000 bytes.\")",
      "else",
      "   print(\"File size is below 1000 bytes.\")",
      "end if"
    ]
  },
  "load": {
    "description": "Returns a `metaLib` object for the provided path to the library binary. Keep in mind that this can be only used on library files. On failure, this method will return `null` instead.",
    "example": [
      "metax = include_lib(\"/lib/metaxploit.so\")",
      "libFolder = File(host_computer(get_shell), \"/lib\")",
      "for file in get_files(libFolder)",
      "   metaLib = load(metax, file.path)",
      "   print(\"Library: \" + lib_name(metaLib) + \" - \" + version(metaLib))",
      "end for"
    ]
  },
  "net_use": {
    "description": "Returns a `netSession` object for the provided IP address and port. Note that if the port zero is provided it will return a `netSession` related to the kernel router. The difference to `load` is that it can be used remotely. The main purpose is to gain a `netSession` and then use `dump_lib` to receive a `metaLib` object to exploit vulnerabilities. In case of failure, this method will return `null`.",
    "example": [
      "metax = include_lib(\"/lib/metaxploit.so\")",
      "ports = used_ports(get_router(\"1.1.1.1\"))",
      "for port in ports",
      "   netSession = net_use(metax, \"1.1.1.1\", port_number(port))",
      "   metaLib = dump_lib(netSession)",
      "   print(\"Library: \" + lib_name(metaLib) + \" - \" + version(metaLib) + \" on port \" + port_number(port))",
      "end for"
    ]
  },
  "rshell_client": {
    "description": "Launches a process on the victim's `computer`, which silently tries to continuously connect in the background to the specified address and port. For the reverse shell to run successfully, the `rshell` service must be installed and the port forward configured correctly on the machine where the server is waiting for the victim's connection.",
    "example": [
      "metax = include_lib(\"/lib/metaxploit.so\")",
      "rshell_client(metax, \"1.1.1.1\", 1222, \"bgprocess\")"
    ]
  },
  "rshell_server": {
    "description": "This method returns a `list` of `shell` objects that have been reverse shell connected to this computer. To manage the connections received, the `rshell` service must be installed on the machine that receives the victims' connections.",
    "example": [
      "metax = include_lib(\"/lib/metaxploit.so\")",
      "shells = rshell_server(metax)",
      "firstShell = shells[0]",
      "chmod(File(host_computer(firstShell), \"/\"), \"o-wrx\", true)"
    ]
  },
  "scan": {
    "description": "Returns a `list` where each item is a `string` representing a memory area which has vulnerabilities related to the provided library. These memory areas can be used to make further scans via `scan_address`. In case of failure, this method returns `null` instead. Here is an example of a memory area: \"0x7BFC1EAA\"",
    "example": [
      "metax = include_lib(\"/lib/metaxploit.so\")",
      "metaLib = load(metax, \"/lib/init.so\")",
      "scanResult = scan(metax, metaLib)",
      "for area in scanResult",
      "   print(\"Memory area containg vulnerability: \" + area)",
      "end for"
    ]
  },
  "scan_address": {
    "description": "Returns a `string` containing information about each vulnerability in the provided library and memory area. In case the scanning fails this method will return `null`.",
    "example": [
      "metax = include_lib(\"/lib/metaxploit.so\")",
      "metaLib = load(metax, \"/lib/init.so\")",
      "scanResult = scan(metax, metaLib)",
      "scanAddress = scan_address(metax, metaLib, scanResult[0])",
      "segments = split(scanAddress, \"Unsafe check: \")[1:]",
      "exploits = []",
      "for segment in segments",
      "   labelStart = indexOf(segment, \"<b>\")",
      "   labelEnd = indexOf(segment, \"</b>\")",
      "   push(exploits, segment[labelStart + 3: labelEnd])",
      "end for",
      "print(\"Available vulnerabilities: \" + join(exploits, \", \"))"
    ]
  },
  "sniffer": {
    "description": "The terminal listens to the network packets of any connection that passes through the computer. When any connection information gets captured, it will print a `string` with the obtained data. In case `saveEncSource` is `true` it will download the source code of the script responsible for encoding. In case the operation fails this method will return `null`.",
    "example": [
      "metax = include_lib(\"/lib/metaxploit.so\")",
      "result = sniffer(metax)",
      "print(result)"
    ]
  },
  "overflow": {
    "description": "Exploits vulnerabilities. The returned value can be of various data types. Therefore the usage of `typeof` is advisable. `optArgs` is required when changing a password or obtaining a `computer` via a router. It should be the desired password or LAN IP, respectively.",
    "example": [
      "metax = include_lib(\"/lib/metaxploit.so\")",
      "metaLib = load(metax, \"/lib/init.so\")",
      "scanResult = scan(metax, metaLib)",
      "target = scanResult[0]",
      "scanAddress = scan_address(metax, metaLib, target)",
      "segments = split(scanAddress, \"Unsafe check: \")",
      "exploit = null",
      " for segment in segments",
      "   hasRequirement = indexOf(segment, \"*\") != null",
      "   if (not hasRequirement) then",
      "      labelStart = indexOf(segment, \"<b>\")",
      "      labelEnd = indexOf(segment, \"</b>\")",
      "      exploit = segment[labelStart + 3: labelEnd]",
      "   end if",
      "end for",
      "if (exploit) then",
      "   print(\"Exploiting... \" + target + \":\" + exploit)",
      "   print(overflow(metaLib, target, exploit))",
      "else",
      "   print(\"No exploit found with zero requirements\")",
      "end if"
    ]
  },
  "version": {
    "description": "Returns a `string` containing the version number of the library. Here is an example of a version number: `\"1.0.0\"`",
    "example": [
      "metax = include_lib(\"/lib/metaxploit.so\")",
      "metaLib = load(metax, \"/lib/init.so\")",
      "print(\"Init.so version: \" + version(metaLib))"
    ]
  },
  "lib_name": {
    "description": "Returns a `string` containing the name of the library. Here is an example of a name: `\"init.so\"`",
    "example": [
      "metax = include_lib(\"/lib/metaxploit.so\")",
      "metaLib = load(metax, \"/lib/init.so\")",
      "print(\"Name for library is: \" + lib_name(metaLib))"
    ]
  },
  "dump_lib": {
    "description": "Returns the `metaLib` associated with the remote service. For example if the `metaxpoit` method `net_use` was used on a ssh port it will return the `metaLib` related to the ssh service. In case the port was zero is will return a `metaLib` related to the kernel router.",
    "example": [
      "metax = include_lib(\"/lib/metaxploit.so\")",
      "ports = used_ports(get_router(\"1.1.1.1\"))",
      "netSession = net_use(metax, \"1.1.1.1\", port_number(ports[0]))",
      "metaLib = dump_lib(netSession)",
      "print(\"Library: \" + lib_name(metaLib) + \" - \" + version(metaLib) + \" on port \" + port_number(ports[0]))"
    ]
  },
  "get_num_conn_gateway": {
    "description": "Returns the number of devices using this router as a gateway. If you obtained your `netSession` from a computer, it will fetch and return the value from its gateway router.",
    "example": [
      "metax = include_lib(\"/lib/metaxploit.so\")",
      "ports = used_ports(get_router(\"1.1.1.1\"))",
      "netSession = net_use(metax, \"1.1.1.1\", port_number(ports[0]))",
      "print(\"Gateway clients: \" + get_num_conn_gateway(netSession))"
    ]
  },
  "get_num_portforward": {
    "description": "Returns the number of ports forwarded by this router. If you obtained your `netSession` from a computer, it will fetch and return the value from its gateway router.",
    "example": [
      "metax = include_lib(\"/lib/metaxploit.so\")",
      "ports = used_ports(get_router(\"1.1.1.1\"))",
      "netSession = net_use(metax, \"1.1.1.1\", port_number(ports[0]))",
      "print(\"Port forwards: \" + get_num_portforward(netSession))"
    ]
  },
  "get_num_users": {
    "description": "Returns the number of user accounts on the system.",
    "example": [
      "metax = include_lib(\"/lib/metaxploit.so\")",
      "ports = used_ports(get_router(\"1.1.1.1\"))",
      "netSession = net_use(metax, \"1.1.1.1\", port_number(ports[0]))",
      "print(\"User accounts: \" + get_num_users(netSession))"
    ]
  },
  "is_any_active_user": {
    "description": "Returns `true` (1) if there is an active user on the system. Otherwise, `false` (0).",
    "example": [
      "metax = include_lib(\"/lib/metaxploit.so\")",
      "ports = used_ports(get_router(\"1.1.1.1\"))",
      "netSession = net_use(metax, \"1.1.1.1\", port_number(ports[0]))",
      "print(\"User Active?: \" + is_any_active_user(netSession))"
    ]
  },
  "is_root_active_user": {
    "description": "Returns `true` (1) if there is an active root on the system. Otherwise, `false` (0).",
    "example": [
      "metax = include_lib(\"/lib/metaxploit.so\")",
      "ports = used_ports(get_router(\"1.1.1.1\"))",
      "netSession = net_use(metax, \"1.1.1.1\", port_number(ports[0]))",
      "print(\"Root Active?: \" + is_root_active_user(netSession))"
    ]
  },
  "device_ports": {
    "description": "Returns a `list` where each item is an open `port` related to the device of the provided LAN IP address. The device needs to be within the network of the `router`. In case of failure, this method will return `null`.",
    "example": [
      "router = get_router",
      "devices = devices_lan_ip(router)",
      "for ip in devices",
      "   ports = device_ports(router, ip)",
      "   openPorts = []",
      "   for port in ports",
      "      if is_closed(port) then continue",
      "      push(openPorts, port)",
      "   end for",
      "",
      "   if (len(openPorts) == 0) then",
      "      print(ip + \" has no open ports\")",
      "   else",
      "      print(ip + \" contains following open ports:\")",
      "      for port in openPorts",
      "         print(\"|-\" +  port.port_number)",
      "      end for",
      "   end if",
      "end for"
    ]
  },
  "devices_lan_ip": {
    "description": "Returns a `list` where each item is a `string` representing a LAN IP address. All devices are within the network of the router and can be reached by using the `ping` method. Some of the devices might be behind a firewall.",
    "example": [
      "router = get_router",
      "devices = devices_lan_ip(router)",
      "for ip in devices",
      "   print(ip + \" found!\")",
      "end for"
    ]
  },
  "bssid_name": {
    "description": "Returns a `string` with the `BSSID` value of the router.",
    "example": [
      "router = get_router",
      "bssid = bssid_name(router)",
      "print(\"BSSID: \" + bssid)"
    ]
  },
  "essid_name": {
    "description": "Returns a `string` with the `ESSID` value of the router.",
    "example": [
      "router = get_router",
      "essid = essid_name(router)",
      "print(\"ESSID: \" + essid)"
    ]
  },
  "firewall_rules": {
    "description": "Returns a `list` where each item is a `string` containing a firewall rule.",
    "example": [
      "router = get_router",
      "rules = firewall_rules(router)",
      "print(\"Firewall rules: \" + join(rules, \", \"))"
    ]
  },
  "kernel_version": {
    "description": "Returns a `string` with the version of the `kernel_router.so` library.",
    "example": [
      "router = get_router",
      "version = kernel_version(router)",
      "print(\"Kernel router version: \" + version)"
    ]
  },
  "local_ip": {
    "description": "Returns a `string` with the local IP address of the router.",
    "example": [
      "router = get_router",
      "localIp = local_ip(router)",
      "print(\"Local IP: \" + localIp)"
    ]
  },
  "public_ip": {
    "description": "Returns a `string` with the public IP address of the router.",
    "example": [
      "router = get_router",
      "publicIp = public_ip(router)",
      "print(\"Public IP: \" + publicIp)"
    ]
  },
  "used_ports": {
    "description": "Returns a `list` where each item is a `port` used inside the router.",
    "example": [
      "router = get_router",
      "ports = used_ports(router)",
      "for port in ports",
      "   print(\"Port \" + port_number(port) + \" is available!\")",
      "end for"
    ]
  },
  "ping_port": {
    "description": "Returns a `port` that is behind the port `number` provided. In case the `port` does not exist `null` gets returned.",
    "example": [
      "router = get_router",
      "ports = used_ports(router)",
      "for port in ports",
      "   pingedPort = ping_port(router, port.port_number)",
      "   if (pingedPort == null) then continue",
      "   print(\"Pinged \" + port_number(pingedPort))",
      "end for"
    ]
  },
  "port_info": {
    "description": "Returns a `string` with information of the port that has been provided. This information contains data on which service is running and which version is used. Example output: `\"http 1.0.0\"`. In case of failure `null` will get returned.",
    "example": [
      "router = get_router",
      "ports = used_ports(router)",
      "for port in ports",
      "   info = port_info(router, port)",
      "   print(info)",
      "end for"
    ]
  },
  "install_service": {
    "description": "Installs the necessary files for the correct functioning of the service and starts it. Returns `true` if the installation has been completed successfully, in case of error a `string` with the details is returned."
  },
  "start_service": {
    "description": "Start the service and open its associated `port` on the local machine. The service needs a port forwarded to the router to be accessible from the outside. Returns `true` if the service has started correctly, in case of error a `string` with the details is returned."
  },
  "stop_service": {
    "description": "Stop the service and close its associated `port` on the local machine. Returns `true` if the service has been stopped correctly, in case of error a `string` with the details is returned."
  },
  "host_computer": {
    "description": "Returns a `computer` related to the `shell`. If an invalid `shell` object gets passed this method will return `null`.",
    "example": [
      "shell = get_shell",
      "computer = host_computer(shell)",
      "print(\"Computer public IP is: \" + public_ip(computer))"
    ]
  },
  "start_terminal": {
    "description": "Launches an active terminal. The terminal's color will change, displaying the IP of the connected shell. Script execution will be stopped upon starting a new terminal, unless this is called from another script that was executed via `shell.launch`. In that case, you will enter the shell after closing your root-level script within that terminal window. Using this method within an SSH encryption process will cause an error to be thrown, preventing further script execution.",
    "example": [
      "start_terminal(get_shell)"
    ]
  },
  "build": {
    "description": "Compiles a plain code file provided in the arguments to a binary. On success, the new binary will be available under the provided build folder. The binary name will be the same as the source file just without file extension. Optionally an allowImport flag can be set which enables to use `import_code` on the binary. All provided paths must be absolute. Returns an empty `string` on success. On failure, it will return a `string` as well but this time containing valuable information on why the compilation failed.",
    "example": [
      "shell = get_shell",
      "computer = host_computer(shell)",
      "touch(computer, home_dir, \"test.src\")",
      "set_content(File(computer, home_dir + \"/test.src\"), \"print(\"\"hello world\"\")\")",
      "buildResult = build(shell, home_dir + \"/test.src\", home_dir + \"/Desktop\")",
      "if buildResult != \"\" then",
      "   print(\"There was an error while compiling: \" + buildResult)",
      "else",
      "   print(\"File has been compiled.\")",
      "end if"
    ]
  },
  "connect_service": {
    "description": "Returns a `shell` if the connection attempt to the provided IP was successful. This method can only connect to ports running an SSH or FTP service. SSH services usually run on port 22 and FTP services usually on port 21. Keep in mind to pass the right service value depending on which service is going to be used. By default, it will pass SSH as the used service. In case of failure a `string` is going to be returned containing details.",
    "example": [
      "shell = get_shell",
      "connectionResult = connect_service(shell, \"1.1.1.1\", 22, \"test\", \"test\")",
      "if typeof(connectionResult) != \"shell\" then",
      "   print(\"There was an error while connecting: \" + connectionResult)",
      "else",
      "   print(\"Connected!\")",
      "end if"
    ]
  },
  "ping": {
    "description": "Returns `true` if the remote address could be reached, `false` otherwise. Firewalls do not block ping requests.",
    "example": [
      "shell = get_shell",
      "isPingable = ping(shell, \"1.1.1.1\")",
      "if isPingable then",
      "   print(\"Ping was successful!\")",
      "else",
      "   print(\"Ping failed!\")",
      "end if"
    ]
  },
  "scp": {
    "description": "Send a `file` to the `computer` related to the provided `shell`. You require permission to read the `file` on the `computer` from which you are uploading and write permissions in the folder of the `computer` you are trying to upload to. In case of failure, this method will return a `string` with the cause. Otherwise, a `number` with the value one gets returned. If any of the passed arguments deviates from the types of the method signature, `null` will be returned. In case the `string` for sourceFile or destinationFolder is empty, an error will be thrown, preventing further script execution.",
    "example": [
      "shell = get_shell",
      "remoteShell = connect_service(shell, \"1.1.1.1\", 22, \"test\", \"test\")",
      "result = scp(remoteShell, \"/bin/ls\", \"/etc/\", shell)",
      "if typeof(result) == \"string\" then",
      "   print(\"There was an error while sending file: \" + result)",
      "else",
      "   print(\"File got sent successfully.\")",
      "end if"
    ]
  },
  "get_balance_subwallet": {
    "description": "Returns a `number` of coins of a given currency. In case of error, a `string` with the details is returned."
  },
  "set_info": {
    "description": "Optional information that the coin creator can store in the Subwallet for any use."
  },
  "get_info": {
    "description": "Returns a `string` with the information stored by the coin creator."
  },
  "delete_subwallet": {
    "description": "Delete the account registered in the cryptocurrency. Returns `true` on success or a `string` with the details of the error. It can return `false` if the account to be deleted does not exist."
  },
  "get_user": {
    "description": "Returns a `string` with the username associated with this subwallet."
  },
  "last_transaction": {
    "description": "Returns a `list` with the information of the last transaction. Index 0 is a `string` with the other subWallet. Index 1 is an int with the amount. Index 2 is a `number` with the direction of the transaction (0 Deposit, 1 Withdrawal). Index 3 is a `string` indicating the date of the transaction."
  },
  "mining": {
    "description": "Starts the process of mining the cryptocurrency. The process leaves the terminal busy until a coin is mined, returning `true`."
  },
  "check_password": {
    "description": "Returns `true` if the credentials are correct, `false` otherwise."
  },
  "wallet_username": {
    "description": "Returns a `string` with the name of the `wallet` to which this subwallet belongs."
  },
  "list_coins": {
    "description": "Returns a `list` where each item is a `string` with the names of the coins available in the `wallet`."
  },
  "get_balance": {
    "description": "Returns a `number` of coins of a given currency. In case of error, a `string` with the details is returned."
  },
  "buy_coin": {
    "description": "Publish a purchase offer indicating the `number` of coins you wish to buy and the price ($) per unit you are willing to pay. The purchase will be finalized if there is any sale offer with a price less than or equal to the one proposed in the purchase. If there is no eligible offer to sell at that time, the offer to buy will remain publicly visible until a new offer to sell satisfies the requirements. If the publication has been successful, true is returned, in case of error a `string` with the details is returned."
  },
  "sell_coin": {
    "description": "Publish a sale offer indicating the amount of coins you want to sell and the price ($) per unit you want to assign. The sale will be finalized if there is any purchase offer with a price greater than or equal to that proposed in the sale. If there is no existing offer to buy that matches the requirements at that time, the offer to sell will remain publicly visible until a new offer to buy satisfies the requirements. If the publication has been successful, true is returned, in case of error a `string` with the details is returned."
  },
  "get_pending_trade": {
    "description": "Returns a `list` with the pending sale or purchase offer of this wallet of a certain currency. Index 0 of the `list` represents the type of offer with a `string` (Buy/Sell), index 1 represents the quantity to be sold or bought, and index 2 represents the price per unit."
  },
  "cancel_pending_trade": {
    "description": "Cancel any pending offer of a certain coin."
  },
  "get_global_offers": {
    "description": "Returns a `map` with all the offers made by any player of a given currency. The Key of the `map` represents the WalletID of the player who has made the offer, The Value of the `map` is a `list` where the index 0 represents the type of offer with a `string` (Buy/Sell), the index 1 represents the amount to sell or buy and the index 2 represents the price per unit."
  },
  "list_global_coins": {
    "description": "Returns a `list` where each item is a `string` containing the names of all the currencies that exist."
  },
  "show_nodes": {
    "description": "Returns a `number` of devices mining a specific coin for the same `wallet`. In case of error a `string` is returned with the details."
  },
  "reset_password": {
    "description": "Change the password of the wallet. Only the account owner can change the password. Returns `true` if the process is completed successfully, in case of error a `string` with the details is returned."
  },
  "get_pin": {
    "description": "Returns a `string` with a PIN that refreshes every few minutes. This PIN is used to obtain an account in cryptocurrency services."
  },
  "delete_mail": {
    "description": "Delete the mail that corresponds with the provided mail id. Returns `true` if it was removed successfully or a `string` with the error message on failure.",
    "example": [
      "metaMail = mail_login(user_mail_address, \"test\")",
      "mails = fetch(metaMail)",
      "results = []",
      "for mail in mails",
      "   segments = split(mail, char(10))",
      "   mailId = segments[2][8:]",
      "   print(delete_mail(metaMail, mailId))",
      "end for",
      "print(\"Deleted every mail!\")"
    ]
  },
  "fetch": {
    "description": "Returns a `list` where each item is a `string` containing mail id, from, subject and a small preview of the content.",
    "example": [
      "metaMail = mail_login(user_mail_address, \"test\")",
      "mails = fetch(metaMail)",
      "results = []",
      "for mail in mails",
      "   segments = split(mail, char(10))",
      "   item = {}",
      "   item.mailId = segments[2][8:]",
      "   item.from = segments[3][6:]",
      "   item.subject = segments[4][9:]",
      "   item.preview = segments[5:]",
      "   push(results, item)",
      "end for",
      "print(results)"
    ]
  },
  "read": {
    "description": "Returns a `string` containing the content of a mail related to the provided mail id. The mail id argument can be obtained with `fetch`. In case the mail cannot be found this method will return \"Mail not found\".",
    "example": [
      "metaMail = mail_login(user_mail_address, \"test\")",
      "mails = fetch(metaMail)",
      "results = []",
      "for mail in mails",
      "   segments = split(mail, char(10))",
      "   mailId = segments[2][8:]",
      "   print(read(metaMail, mailId))",
      "end for"
    ]
  },
  "send": {
    "description": "Send a new mail to the provided email address. Keep in mind that the subject can not exceed 128 characters and the content size should not exceed 160000 characters. Returns `true` if the mail has been sent correctly, otherwise returns a `string` containing the error.",
    "example": [
      "metaMail = mail_login(user_mail_address, \"test\")",
      "result = send(metaMail, user_mail_address, \"test subject\", \"test message\")",
      "if typeof(result) == \"string\" then",
      "   print(\"There was an error while sending mail: \" + result)",
      "else",
      "   print(\"Mail got send successfully.\")",
      "end if"
    ]
  },
  "port_number": {
    "description": "Returns the `number` which is used for the port.",
    "example": [
      "router = get_router",
      "ports = used_ports(router)",
      "for port in ports",
      "   print(\"Port \" + port_number(port) + \" is in use!\")",
      "end for"
    ]
  },
  "is_closed": {
    "description": "Returns `true` if this port is closed, `false` if the port is open.",
    "example": [
      "router = get_router",
      "ports = used_ports(router)",
      "for port in ports",
      "   state = \"open\"",
      "   if (is_closed(port)) then state = \"closed\"",
      "   print(\"Port \" + port_number(port) + \" is \" + state + \"!\")",
      "end for"
    ]
  },
  "get_lan_ip": {
    "description": "Returns a `string` containing the local IP address of the computer to which the port is pointing.",
    "example": [
      "router = get_router",
      "ports = used_ports(router)",
      "for port in ports",
      "   print(\"Port \" + port_number(port) + \" is pointed to \" + get_lan_ip(port) + \"!\")",
      "end for"
    ]
  },
  "reset_ctf_password": {
    "description": "Resets the password of your CTF account. Returns a `number` with the value one if resetting was successful; otherwise, it will return a `string` containing the reason for failure.",
    "example": [
      "reset_ctf_password(\"mysafepassword\")"
    ]
  },
  "reverse": {
    "description": "Reverses the order of all values in the `list`. This operation will mutate the `list`.",
    "example": [
      "myList = [42, 1, 3]",
      "reverse(myList)",
      "print(\"Reversed list: \" + myList.split(\", \"))"
    ]
  },
  "trim": {
    "description": "Returns a new `string` stripped of any spacing at the beginning and ending. If any value gets passed that is not a `string` this method will return `null`.",
    "example": [
      "myString = \"    42   \"",
      "print(trim(myString))"
    ]
  },
  "lastIndexOf": {
    "description": "Returns a `number` indicating the last matching index of the provided value inside the `string`. If the value does not exist inside the `string`, `-1` is returned. If any of the provided values deviates from the defined types in the method signature, this method will return `null`.",
    "example": [
      "myString = \"42 as an answer is wrong\"",
      "index = lastIndexOf(myString, \"wrong\")",
      "if index != -1 then",
      "   print(\"Invalid information spotted at: \" + index)",
      "else",
      "   print(\"Information seems valid.\")",
      "end if"
    ]
  },
  "funcRef": {
    "description": "Returns a `map` which enables to extend function references with custom methods.",
    "example": [
      "funcRef.signature = function",
      "   return str(@self)",
      "end function",
      "print (@print).signature"
    ]
  },
  "list": {
    "description": "Returns a `map` which enables to extend list types with custom methods.",
    "example": [
      "list.map = function(callback)",
      "   newList = []",
      "   for item in self",
      "      newList.push(callback(item, __item_idx))",
      "   end for",
      "   return newList",
      "end function",
      "myMapFunction = function(item, index)",
      "   print \"Mapping value at index: \" + index",
      "   return item.myValue",
      "end function",
      "print [{ \"myValue\": 24 }].map(@myMapFunction)"
    ]
  },
  "number": {
    "description": "Returns a `map` which enables to extend number types with custom methods.",
    "example": [
      "number.bitwise = function(operator, right)",
      "  return bitwise(operator, self, right)",
      "end function",
      "print (1234).bitwise(\">>\", 1)"
    ]
  }
}