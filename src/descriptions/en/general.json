{
    "$meta": {
        "description": "Use `if` blocks to do different things depending on some condition. Include zero or more `else if` blocks and one optional `else` block. Use a `while` block to loop as long as a condition is true. A `for` loop can loop over any `list`, including ones easily created with the `range` function. The `break` statement jumps out of a `while` or `for` loop. The `continue` statement jumps to the top of the loop, skipping the rest of the current iteration.",
        "example": [
            "// if block",
            "if 2+2 == 4 then",
            "   print \"math works!\"",
            "else if pi > 3 then",
            "   print \"pi is tasty\"",
            "else if \"a\" < \"b\" then",
            "   print \"I can sort\"",
            "else",
            "   print \"last chance\"",
            "end if",
            "",
            "// while loop",
            "s = \"Spam\"",
            "while s.len < 50",
            "   s = s + \", spam\"",
            "end while",
            "print s + \" and spam!\"",
            "",
            "// for loop",
            "for i in range(10, 1)",
            "   print i + \"...\"",
            "end for",
            "print \"Liftoff!\""
        ]
    },
    "mail_login": {
        "description": "Returns a `MetaMail` entity if the login has been correct. In case an issue appeared this function will return `null`.",
        "example": [
            "metaMail = mail_login(\"test@test.com\", \"test\")",
            "if metaMail == null then",
            "   print(\"Loggin failed.\")",
            "else",
            "   print(\"You've got mail.\")",
            "end if"
        ]
    },
    "parent_path": {
        "description": "Returns a `string` which is the potential parent path of the path provided. Keep in mind that the path provided needs to be properly formatted.",
        "example": [
            "print(\"Is proper parent path: \" + (parent_path(\"/my/test/path\") == \"/my/test\"))"
        ]
    },
    "hasIndex": {
        "description": "Depending on data type this function checks if the provided index is available inside the value. To get a better idea about the behaviour look into the `hasIndex` methods related to `string`, `list` and `map`.",
        "example": [
            "print(\"List has index: \" + hasIndex([1, 2, 3], 2)"
        ]
    },
    "typeof": {
        "description": "Returns a `string` containing the type of the entity provided. There are following types by default: `\"aptclientLib\"`, `\"blockchainLib\"`, `\"ctfEvent\"`, `\"coin\"`, `\"computer\"`, `\"cryptoLib\"`, `\"file\"`, `\"function\"`, `\"list\"`, `\"map\"`, `\"MetaLib\"`, `\"MetaMail\"`, `\"MetaxploitLib\"`, `\"NetSession\"`, `\"null\"`, `\"number\"`, `\"port\"`, `\"router\"`, `\"service\"`, `\"shell\"`, `\"ftpshell\"`, `\"string\"`, `\"subwallet\"`, `\"wallet\"`. Custom types can be added as well by using the `classID` property in a `map`.",
        "example": [
            "myObj = { \"classID\": \"myType\" }",
            "if typeof(myObj) == \"myType\" then",
            "   print(\"Object is myType.\")",
            "else",
            "   print(\"Object is not myType.\")",
            "end if"
        ]
    },
    "get_router": {
        "description": "Returns by default the `router` to which the executing computer is connected to. Optionally an IP address can be provided. In case of failure `null` is returned.",
        "example": [
            "router = get_router",
            "if router.local_ip == get_shell.host_computer.network_gateway then",
            "   print(\"Router is equal to network gateway.\")",
            "else",
            "   print(\"Router is not equal to network gateway.\")",
            "end if"
        ]
    },
    "get_switch": {
        "description": "Returns the switch on the local network whose IP address matches, otherwise it returns `null`.",
        "example": [
            "router = get_switch(\"192.168.0.2)",
            "print(\"IP address of switch: \" + router.local_ip)"
        ]
    },
    "nslookup": {
        "description": "Returns the IP address for the provided web address. In case the web address cannot be found a `string` gets returned containing the following message: `\"Not found\"`",
        "example": [
            "url = params[0]",
            "print(\"IP for website is: \" + nslookup(url))"
        ]
    },
    "print": {
        "description": "Print a message on the Terminal. Optionally replacing can be enabled which will replace all previous prints. This can be useful for creating a loading bar for example. There is also the possibility of styling output by using TextMeshPro rich-text tags.",
        "example": [
            "for i in range(9)",
            "   print((\"#\" * (9 - i)) + (\"-\" * i) , true)",
            "   wait(0.2)",
            "end for"
        ]
    },
    "clear_screen": {
        "description": "Removes any text existing in a Terminal previous to this point.",
        "example": [
            "for i in range(9)",
            "   clear_screen",
            "   print((\"#\" * (9 - i)) + (\"-\" * i))",
            "   wait(0.2)",
            "end for"
        ]
    },
    "active_user": {  
        "description": "Returns a `string` with the name of the user who is executing the current script.",
        "example": [
            "print(\"Current active user: \" + active_user)"
        ]
    },
    "home_dir": {
        "description": "Returns a `string` with the home folder path of the user who is executing the current script.",
        "example": [
            "print(\"Home dir of current user: \" + home_dir)"
        ]
    },
    "get_shell": {
        "description": "Returns the `shell` that is executing the script. Optionally a username and password can be provided. In case the username or password does not match an existing user this method will return `null`.",
        "example": [
            "shell = get_shell(\"root\", \"test\")",
            "if shell == null then",
            "   print(\"Couldn't obtain root shell.\")",
            "else",
            "   print(\"Obtained root shell.\")",
            "end if"
        ]
    },
    "indexes": {
        "description": "Depending on data type this function returns a `list` with all available indexes. To get a better idea about the behaviour look into the `indexes` methods related to `string`, `list` and `map`.",
        "example": [
            "indexesOfStr = indexes(\"test\")",
            "print(\"Following indexes are available: \" + indexesOfStr.join(\", \"))"
        ]
    },
    "values": {
        "description": "Depending on data type this function returns a `list` with all available values. To get a better idea about the behaviour look into the `values` methods related to `string`, `list` and `map`.",
        "example": [
            "indexesOfStr = values(\"test\")",
            "print(\"Following values are available: \" + indexesOfStr.join(\", \"))"
        ]
    },
    "indexOf": {
        "description": "Depending on the data type this function searches for the index of the provided value. To get a better idea about the behaviour look into the `indexOf` methods related to `string`, `list` and `map`.",
        "example": [
            "index = indexOf(\"test\", \"e\")",
            "print(\"e is at: \" + index)"
        ]
    },
    "len": {
        "description": "Depending on data type this function returns the length of the provided value. To get a better idea about the behaviour look into the `len` methods related to `string`, `list` and `map`.",
        "example": [
            "length = len(\"test\")",
            "print(\"Length of string is: \" + length)"
        ]
    },
    "shuffle": {
        "description": "Depending on data type this function will shuffle data. Instead of returning the newly shuffled data, this function will mutate the data. To get a better idea about the behaviour look into the `shuffle` methods related to `list` and `map`.",
        "example": [
            "list = [0, 1, 2, 3, 4, 5]",
            "shuffle(list)",
            "print(\"And the winner is: \" + list[0])"
        ]
    },
    "val": {
        "description": "Casts a `string` to a `number`. In case the provided `string` does not represent a valid `number` the `number` zero will get returned.",
        "example": [
            "num = val(\"1.25\")",
            "print(\"Number in string is: \" + num)"
        ]
    },
    "lower": {
        "description": "Returns a `string` which is the lowercase transformed version of the provided `string`.",
        "example": [
            "myString = lower(\"HELLO WORLD\")",
            "print(myString)"
        ]
    },
    "upper": {
        "description": "Returns a `string` which is the uppercase transformed version of the provided `string`.",
        "example": [
            "myString = upper(\"hello world\")",
            "print(myString)"
        ]
    },
    "sum": {
        "description": "Depending on data type this function returns the sum of all items. To get a better idea about the behaviour look into the `sum` methods related to `list` and `map`.",
        "example": [
            "list = [0, 1, 2, 3, 4, 5]",
            "print(\"Sum of all items is: \" + sum(list))"
        ]
    },
    "pop": {
        "description": "Depending on data type this function will return the last item in the provided value. Additionally, this function removes the last item and therefore mutates the object. To get a better idea about the behaviour look into the `pop` methods related to `list` and `map`.",
        "example": [
            "list = [0, 1, 2, 3, 4, 5]",
            "print(\"The last item is: \" + pop(list))"
        ]
    },
    "pull": {
        "description": "Depending on data type this function will return the first item in the provided value. Additionally, this function removes the first item and therefore mutates the object. To get a better idea about the behaviour look into the `pull` methods related to `list` and `map`.",
        "example": [
            "list = [0, 1, 2, 3, 4, 5]",
            "print(\"The first item is: \" + pull(list))"
        ]
    },
    "push": {
        "description": "Depending on data type this function will append a value to the provided object. As a result, the object will get mutated. To get a better idea about the behaviour look into the `push` methods related to `list` and `map`.",
        "example": [
            "list = [0, 1, 2, 3, 4, 5]",
            "push(list, 42)",
            "print(\"The answer to everything is: \" + pop(list))"
        ]
    },
    "sort": {
        "description": "Sort `list` values alphanumerically. This operation will mutate the `list`. Optionally a key can be provided which which is used in case the items are maps. Additionally, this method will return the updated `list`.",
        "example": [
            "list = [9, 3, 5, 7]",
            "sort(list)",
            "print(\"Sorted list: \" + list.join(\", \"))"
        ]
    },
    "remove": {
        "description": "Depending on the data type this function will remove a value in the provided object. As a result, the object will get mutated. To get a better idea about the behaviour look into the `remove` methods related to `list` and `map`.",
        "example": [
            "list = [9, 3, 5, 7]",
            "remove(list, 5)",
            "print(\"List after removal: \" + list.join(\", \"))"
        ]
    },
    "user_input": {
        "description": "Puts script execution on hold to receive input from the user. Input will be submitted by pressing Enter. Additionally, it is also possible to style the output message by using TextMeshPro rich-text tags. There are two optional arguments. If the `isPass` flag is `true` the input will be masked by asterisk signs. In case the anyKey flag is `true` instead of waiting for the Enter key to be pressed any key press will be captured instantly.",
        "example": [
            "num = 0",
            "aboveIncludingZeroTag = \"<color=yellow>\"",
            "belowZeroTag = \"<color=red>\"",
            "while (true)",
            "   clear_screen",
            "   output = aboveIncludingZeroTag + num" , 
            "   if (num < 0) then",
            "      output = belowZeroTag + num",
            "   end if",
            "   print(output)",
            "   key = user_input(\"Press arrow up/down to change value.\", false, true)",
            "   if (key == \"UpArrow\") then",
            "      num = num + 1",
            "   else if (key == \"DownArrow\") then",
            "       num = num - 1",
            "   else",
            "       exit(\"Bye!\")",
            "   end if",
            "end while"
        ]
    },
    "include_lib": {
        "description": "Enables to include library binaries which can be used inside your script. In case of success, an object will get returned related to the provided library. Otherwise `null` gets returned. Keep in mind that this function can be only used for library binaries. In case you want to import custom scripts or binaries into your project you should use `import_code` instead.",
        "example": [
            "crypto = include_lib(\"/lib/crypto.so\")",
            "if crypto == null then",
            "   print(\"Crypto library couldn't get imported.\")",
            "else",
            "   print(\"Crypto library got imported.\")",
            "end if"
        ]
    },
    "import_code": {
        "description": "Enables to import code from different sources into one file. This is useful in case you want to split code into different files and also to avoid any limitation in regards to text file character limits. Note that `import_code` requires an absolute path and is called while compiling the file into a binary instead of during runtime. Additionally `import_code` cannot be nested. Code can be either imported from plain text files or binaries that have `\"allow import\"` enabled. `import_code` is also parsed wherever it is found, not even a `//` comment will prevent it being evaluated.",
        "example": [
            "//Content of main.src",
            "import_code(\"/home/user/my_module.src\")",
            "print(\"bye\")",
            "//Content of my_module.src",
            "print(\"hello!\")"
        ]
    },
    "exit": {
        "description": "Stops any execution of the currently running script. Optionally a message can be provided which will be shown in the Terminal. There is also the possibility of styling output by using TextMeshPro rich-text tags.",
        "example": [
            "while (true)",
            "   shouldExit = lower(user_input(\"Want to exit? (Y/N)\"))",
            "   if (shouldExit == \"y\") then",
            "      exit(\"See you!\")",
            "   end if",
            "end while"
        ]
    },
    "user_mail_address": {
        "description": "Returns a `string` containing the email address of the user who is executing the script.",
        "example": [
            "print(\"My EMail address is: \" + user_mail_address)"
        ]
    },
    "user_bank_number": {
        "description": "Returns a `string` containing the bank number of the user who is executing the script.",
        "example": [
            "print(\"My Bank number is: \" + user_bank_number)"
        ]
    },
    "whois": {
        "description": "Returns a `string` containing the administrator information behind an IP address provided. In case of failure the returned `string` will contain an error message instead.",
        "example": [
            "adminInfo = whos(\"1.1.1.1\")",
            "infoLines = adminInfo.split(char(10))",
            "infoObject = {}",
            "infoObject.domainName = infoLines[0].split(\":\")[1].trim",
            "infoObject.administrativeContact = infoLines[1].split(\":\")[1].trim",
            "infoObject.emailAddress = infoLines[2].split(\":\")[1].trim",
            "infoObject.phone = infoLines[3].split(\":\")[1].trim",
            "print(\"Phone number: \" + infoObject.phone)"
        ]
    },
    "wait": {
        "description": "Puts script execution on hold. Optionally the duration can be provided via the time argument. By default, the duration will be 1 second. The duration cannot be below 0.01 or above 300.",
        "example": [
            "start = time",
            "wait(5)",
            "elapsed = time - start",
            "print(\"Waited: \" + elapsed)"
        ]
    },
    "command_info": {
        "description": "Returns a `string` value of a translation. Translations include commands, documentation and other game-related things. Checkout [Grey-Texts](https://github.com/LoadingHome/Grey-Texts/blob/main/EnglishLang.json) for an overview of all available keys.",
        "example": [
            "print(command_info(\"LS_USAGE\"))"
        ]
    },
    "program_path": {
        "description": "Returns a `string` containing the path of the script that is currently executed.",
        "example": [
            "path = program_path",
            "print(\"Script gets executed within: \" + parent_path(path))"
        ]
    },
    "current_path": {
        "description": "Returns a `string` containing the path in which script that is currently executed from.",
        "example": [
            "path = current_path",
            "print(\"PWD: \" + path)"
        ]
    },
    "format_columns": {
        "description": "Returns a `string` which is the formatted version of the provided text. Keep in mind that TextMeshPro rich-text tags might screw up the output. When using tags consider applying these after formatting.",
        "example": [
            "text = \"FIRST SECOND THIRD",
            "1 2 3\"",
            "print(format_columns(text))"
        ]
    },
    "current_date": {
        "description": "Returns a `string` containing the current date and time. Ingame time passes 15 times as fast as real-time - 4 seconds per in-game minute. The initial time after every wipe will be the 1st of January 2000 at 6:00 AM. Additionally, the game time will not proceed while the server is offline.\n* Output schema: `\"[day]/[month]/[year] - [hours]:[minutes]\"`\n* Example output: `\"27/Jan/2000 - 08:19\"`\n",
        "example": [
            "dateStr = current_date",
            "dateSegments = dateStr.split(\" - \")",
            "date = dateSegments[0].split(\"/\")",
            "day = date[0]",
            "month = date[1]",
            "year = date[2]",
            "dateTime = dateSegments[1].split(\":\")",
            "hours = dateTime[0]",
            "minutes = dateTime[1]",
            "print(\"Current day: \" + day)"
        ]
    },
    "is_lan_ip": {
        "description": "Returns `true` in case the provided IP address is a valid Lan IP address. Otherwise `false` will get returned.",
        "example": [
            "print(\"Is Lan IP: \" + is_lan_ip(\"192.168.0.1\"))"
        ]
    },
    "is_valid_ip": {
        "description": "Returns `true` in case the provided IP address is valid. Otherwise `false` will get returned.",
        "example": [
            "print(\"Is valid IP: \" + is_valid_ip(\"1.1.1.1\"))"
        ]
    },
    "bitwise": {
        "description": "Enables to perform bitwise operations. Supported operators are: `\"&\"`, `\"|\"`, `\"^\"`, `\"<<\"`, `\">>\"`, `\">>>\"`. Returns a `number`. Warning: If either operand is >= `0x80000000`, it always returns 0",
        "example": [
            "num = params[0].to_int",
            "isOdd = bitwise(\"&\", num, 1) == 1",
            "if isOdd then",
            "   print(\"Number is odd.\")",
            "else",
            "   print(\"Number is even.\")",
            "end if"
        ]
    },
    "abs": {
        "description": "Returns the absolute value of `number`.",
        "example": [
            "a = 1",
            "b = 5",
            "difference = abs(a - b)",
            "print(\"Difference between a and b is: \" + difference)"
        ]
    },
    "acos": {
        "description": "Returns the inverse cosine (in radians) of a `number`.",
        "example": [
            "adjacent = 8",
            "hypotenuse = 10",
            "calcAngle = acos(adjacent / hypotenuse)",
            "print(\"Angle: \" + calcAngle)"
        ]
    },
    "asin": {
        "description": "Returns the inverse sine (in radians) of a `number`.",
        "example": [
            "opposite = 6",
            "hypotenuse = 10",
            "calcAngle = acos(opposite / hypotenuse)",
            "print(\"Angle: \" + calcAngle)"
        ]
    },
    "atan": {
        "description": "Returns the inverse tangent (in radians) of a `number`.",
        "example": [
            "opposite = 8",
            "hypotenuse = 10",
            "calcAngle = atan(opposite / hypotenuse)",
            "print(\"Angle: \" + calcAngle)"
        ]
    },
    "tan": {
        "description": "Returns the tangent of a `number` in radians.",
        "example": [
            "degrees = 90",
            "tanFromDegrees = tan(degress * pi / 180)",
            "print(\"Tan from degrees: \" + tanFromDegrees)"
        ]
    },
    "cos": {
        "description": "Returns the cosine of a `number` in radians.",
        "example": [
            "radians = 1",
            "radius = 10",
            "circleX = cos(radians) * radius",
            "print(circleX)"
        ]
    },
    "code": {
        "description": "Returns the Unicode `number` of the first character of the string. In case an empty `string` is provided the script execution will crash.",
        "example": [
            "key = user_input(\"Press a key!\", false, true)",
            "isA = key.code == 97",
            "if isA then",
            "   print(\"You pressed A.\")",
            "else",
            "   print(\"You did not press A.\")",
            "end if"
        ]
    },
    "char": {
        "description": "Returns the UTF-16 character `string` related to the provided unicode `number`. The provided `number` needs to be between 0 and 65535. Any `number` which is outside this range will cause the script to throw a runtime error. Beware when passing non-ASCII values to intrinsics as they will likely get re-encoded as UTF-8. For example, `md5(char(255))` will actually return the hash of the two-byte sequence `0xC3` `0xBF`.",
        "example": [
            "key = user_input(\"Press a key!\", false, true)",
            "isA = key == char(97)",
            "if isA then",
            "   print(\"You pressed A.\")",
            "else",
            "   print(\"You did not press A.\")",
            "end if"
        ]
    },
    "sin": {
        "description": "Returns the sine of a `number` in radians.",
        "example": [
            "radians = 1",
            "radius = 10",
            "circleY = sin(radians) * radius",
            "print(circleY)"
        ]
    },
    "floor": {
        "description": "Returns `number` rounded down to the integer value of the provided `number`.",
        "example": [
            "price = 25.43467",
            "floored = floor(price * 100) / 100",
            "print(\"Floored price: \" + floored)"
        ]
    },
    "range": {
        "description": "Returns a `list` where each item is a `number`. By default, the `list` starts with the `number` zero and increments by one for each item. Optionally start and end can be defined. Additionally, the incremental value can be changed as well. In case the incremental value is zero this function will throw a runtime error.",
        "example": [
            "print(\"Countdown:\")",
            "for num in range(10)",
            "   print(num)",
            "end for",
            "print(\"Done!\")"
        ]
    },
    "round": {
        "description": "Returns `number` rounded to the integer value of the provided `number`.",
        "example": [
            "price = 25.43467",
            "rounded = round(price * 100) / 100",
            "print(\"Price: \" + rounded)"
        ]
    },
    "rnd": {
        "description": "Returns a random `number` between 0 and 1. Optionally a seed `number` can be provided.",
        "example": [
            "min = 10",
            "max = 20",
            "output = floor(rnd * (max - min + 1) + min)",
            "input = user_input(\"Guess a number between 10 and 20!\").to_int",
            "if (input == output) then",
            "   print(\"You guessed right!\")",
            "else",
            "   print(\"You failed! The number was \" + output)",
            "end if"
        ]
    },
    "sign": {
        "description": "Returns a one or minus one, indicating the sign of the number passed as argument. If the input is zero, it will be returned as-is.",
        "example": [
            "print(sign(40))",
            "print(sign(-40))",
            "print(sign(0))"
        ]
    },
    "sqrt": {
        "description": "Returns the square root of a `number`.",
        "example": [
            "a = 3",
            "b = 4",
            "calcHypotenuse = sqrt((a * a) + (b * b))",
            "print(\"Hypotenuse: \" + calcHypotenuse)"
        ]
    },
    "str": {
        "description": "Returns the `string` value of provided data. Can be used to turn a `number` into a `string` or to get the signature of a `function`.",
        "example": [
            "signature = str(@user_input)",
            "argSegment = signature[9:signature.len - 1]",
            "args = argSegment.split(\",\")",
            "print(\"Function has \" + args.len + \" arguments.\")"
        ]
    },
    "ceil": {
        "description": "Returns `number` rounded up to the integer value of the provided `number`.",
        "example": [
            "price = 25.43467",
            "upperPrice = ceil(price * 100) / 100",
            "print(\"Upper price: \" + upperPrice)"
        ]
    },
    "pi": {
        "description": "Returns the `number` PI to the precision of six.",
        "example": [
            "radius = 10",
            "circumference = 2 * pi * radius",
            "print(\"Circumference: \" + circumference)"
        ]
    },
    "launch": {
        "description": "Launches the binary which is at the provided path. Optionally parameters can be passed. Returns `true` when launch was successful otherwise this method will return `false`. Cannot be used to execute binaries with an EXE extension.",
        "example": [
            "shell = get_shell(\"root\", \"test\")",
            "launch(shell, \"/bin/cat\", \"/etc/passwd\")"
        ]
    },
    "launch_path": {
        "description": "Returns a `string` containing the path of the script that is currently executed.",
        "example": [
            "path = program_path",
            "print(\"Script gets executed within: \" + parent_path(path))"
        ]
    },
    "slice": {
        "description": "Returns a sliced `list`. Valid data types for slicing are `string` and `list`. The returned `list` will contain all elements related to the provided start and end index.",
        "example": [
            "myString = \"not your text\"",
            "print(\"my \" + slice(myString, 9))"
        ]
    },
    "md5": {
        "description": "Returns the md5 hash `string` of the provided `string`.",
        "example": [
            "passwordHash = md5(\"test\")",
            "print(\"Hash for the password 'test' is \" + passwordHash)"
        ]
    },
    "hash": {
        "description": "Returns numeric hash for the provided data.",
        "example": [
            "hashA = hash({ \"a\": 2, \"b\": 1 })",
            "hashB = hash({ \"b\": 1, \"a\": 2 })",
            "if (hashA == hashB) then",
            "   print(\"Objects are alike!\")",
            "else",
            "   print(\"Objects are different!\")",
            "end if"
        ]
    },
    "time": {
        "description": "Returns a `number` of seconds representing the elapsed time since the script got started.",
        "example": [
            "start = time",
            "for i in range(10000)",
            "   var = i * 100",
            "end for",
            "endTime = time - start",
            "print(\"Script execution done within: \" + endTime)"
        ]
    },
    "bitAnd": {
        "description": "Performs a bitwise AND for the provided values. Returns a `number`. Warning: If either operand is >= `0x80000000`, it always returns 0.",
        "example": [
            "print(\"Result of bitwise AND: \" + bitAnd(1, 2))"
        ]
    },
    "bitOr": {
        "description": "Performs a bitwise OR for the provided values. Returns a `number`. Warning: If either operand is >= `0x80000000`, it always returns 0.",
        "example": [
            "print(\"Result of bitwise OR: \" + bitOr(1, 2))"
        ]
    },
    "bitXor": {
        "description": "Performs a bitwise XOR for the provided values. Returns a `number`. Warning: If either operand is >= `0x80000000`, it always returns 0.",
        "example": [
            "print(\"Result of bitwise XOR: \" + bitXor(1, 2))"
        ]
    },
    "log": {
        "description": "Returns the natural logarithm of a `number`. By default, the base is 10. Optionally the base can be changed.",
        "example": [
            "a = 2",
            "b = 8",
            "baseLog = log(a) / log(b)",
            "print(\"Base log is: \" + baseLog)"
        ]
    },
    "yield": {
        "description": "Waits for the next tick.",
        "example": [
            "while (true)",
            "   yield",
            "   print(\"tick\")",
            "end while"
        ]
    },
    "get_custom_object": {
        "description": "Returns `map` which is shared throughout all script executions. Can be helpful in case forwarding an entity is desired.",
        "example": [
            "get_custom_object.shouldEndScript = false",
            "while (get_custom_object.shouldEndScript)",
            "   print(\"Waiting...\")",
            "   wait(2)",
            "end while"
        ]
    },
    "insert": {
        "description": "Depending on the data type this function will insert a value to the provided index. Due to the insertion, the object will be mutated. To get a better idea about the behaviour look into the `insert` method related to `list` or `string`.",
        "example": [
            "list = [2, 3, 4]",
            "insert(list, 2, 42)",
            "print(\"List with inserted item: \" + list.join(\", \"))"
        ]
    },
    "to_int": {
        "description": "Returns a `number` which is parsed from the `string` as an integer. In case the `string` is not numeric it will return the original `string`.",
        "example": [
            "myString = \"1\"",
            "print(to_int(myString) + 41)"
        ]
    },
    "join": {
        "description": "Returns a concatenated `string` containing all stringified values inside the `list`. These values will be separated via the provided separator.",
        "example": [
            "myList = [42, 1, 3]",
            "print(join(myList, \" .-*'*-. \"))"
        ]
    },
    "split": {
        "description": "Returns a `list` where each item is a segment of the `string`. The separation depends on the provided separator `string`. Keep in mind that for some odd reason, this method is using regular expressions for matching.",
        "example": [
            "myString = \"42 as an answer is wrong\"",
            "segments = split(myString, \" \")",
            "if segments[0] != \"42\" then",
            "   print(\"Invalid information spotted!\")",
            "else",
            "   print(\"Information seems valid!\")",
            "end if"
        ]
    },
    "replace": {
        "description": "Depending on the data type this function will replace a value in the provided object. Due to the replacement, the object might get mutated. To get a better idea about the behaviour look into the `replace` method related to `map`, `list` or `string`.",
        "example": [
            "myString = \"42 as an answer is wrong\"",
            "newString = replace(myString, \"wrong\", \"right\")",
            "print(newString)"
        ]
    },
    "replace_regex": {
        "description": "Similar behaviour to replace but instead supporting regular expressions. Supported regular expression options: [click here](https://learn.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-options)",
        "example": [
            "myString = \"42 as an answer is wrong\"",
            "newString = replace_regex(myString, \"\\w+$\", \"right\")",
            "print(newString)"
        ]
    },
    "is_match": {
        "description": "Uses regular expression to check if a string is matching a certain pattern. Supported regular expression options: [click here](https://learn.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-options)",
        "example": [
            "myString = \"42 as an answer is wrong\"",
            "hasWordAtTheEnd = is_match(myString, \"\\w+$\")",
            "print(hasWordAtTheEnd)"
        ]
    },
    "matches": {
        "description": "Returns all search results for the provided regular expression. The result will be a map where the key contains the index and the value contains the match value. Supported regular expression options: [click here](https://learn.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-options)",
        "example": [
            "myString = \"42 as an answer is wrong\"",
            "result = matches(myString, \"w\")",
            "print(result)"
        ]
    },
    "get_ctf": {
        "description": "Returns `ctfEvent` object if there is one available."
    },
    "show": {
        "description": "Shows all packages available in the repository. The repository must be added in the `\"/etc/apt/sources.txt\"` file."
    },
    "search": {
        "description": "Search specifically for the package in any of the repositories listed in `\"/etc/apt/sources.txt\"`."
    },
    "update": {
        "description": "Update the `list` of available packages after adding a new repository in `\"/etc/apt/sources.txt\"`, or if the remote repository has updated its information in `\"/server/conf/repod.conf\"`."
    },
    "add_repo": {
        "description": "Add the repository address in the `\"/etc/apt/sources.txt\"` file."
    },
    "del_repo": {
        "description": "Remove the repository address in the `\"/etc/apt/sources.txt\"` file."
    },
    "install": {
        "description": "Install the program or library from a remote repository listed in `\"/etc/apt/sources.txt\"`. Unless a path is specified, the program installs in `\"/lib\"` if it is a library or in `\"/bin\"` otherwise."
    },
    "check_upgrade": {
        "description": "Check if there is a newer version of the file in the repository."
    },
    "coin_price": {
        "description": "Returns `number` with the current unit value of the currency. In case of error a `string` is returned with the details."
    },
    "show_history": {
        "description": "Returns a `map` with the latest changes in the value of a specific currency. The Key of the `map` is the index represented by a `number`. Value contains a `list`, where index 0 is the price of the coin it had in the past, index 1 indicates the date on which the price change occurred."
    },
    "amount_mined": {
        "description": "Returns a `number` representing the total amount of mined coins."
    },
    "get_coin": {
        "description": "Returns a `coin` used to manage the currency. A `string` with the details is returned in case of an error."
    },
    "login_wallet": {
        "description": "Returns a `wallet` or a `string` in case of error indicating the reason."
    },
    "create_wallet": {
        "description": "Returns a `wallet`, used to manage cryptocurrencies. In case of error a `string` is returned with the details."
    },
    "delete_coin": {
        "description": "Remove a cryptocurrency from the world. The credentials used in the creation of the currency are necessary."
    },
    "set_cycle_mining": {
        "description": "Assign the hours (game time) that each mining cycle lasts. When a cycle ends, it is decided who gets the reward (1 coin) and the next cycle begins."
    },
    "get_cycle_mining": {
        "description": "Returns a `number` of hours (game time) that each mining cycle lasts. When a cycle ends, it is decided who gets the reward (1 coin) and the next cycle begins."
    },
    "get_reward": {
        "description": "Returns a `number` of coins that will be received as a reward after each mining cycle."
    },
    "set_reward": {
        "description": "Assign the reward that miners will receive after each mining cycle."
    },
    "transaction": {
        "description": "Make a transaction of the currency between the indicated subwallets. In case of error, a `string` with the details is returned."
    },
    "create_subwallet": {
        "description": "Register a new account in the `coin` that can be used to manage services such as stores. It is necessary to use the PIN that the owner of the `wallet` that wants to register has to provide."
    },
    "get_subwallet": {
        "description": "Returns a `subWallet`, in case of error it returns a `string` with the details."
    },
    "get_subwallets": {
        "description": "Returns a `list` where each item is a `subWallet` including all the accounts registered in the cryptocurrency, in case of error it returns a `string` with the details."
    },
    "set_address": {
        "description": "Configure a valid address that will be shown to users who do not have the currency, indicating where to register."
    },
    "get_address": {
        "description": "Returns the configured address that will be shown to users who do not have the currency, indicating where they have to register."
    },
    "get_mined_coins": {
        "description": "Returns a `number` of coins that have been mined so far."
    },
    "get_ports": {
        "description": "Returns a `list` of `port`s on the `computer` which are active.",
        "example": [
            "router = get_router",
            "ports = get_ports(host_computer(get_shell))",
            "for port in ports",
            "    print(\"Info: \" + router.port_info(port))",
            "end for"
        ]
    },
    "get_name": {
        "description": "Returns the hostname of the machine.",
        "example": [
            "computerName = get_name(host_computer(get_shell))",
            "print(\"The name of your machine is \" + computerName)"
        ]
    },
    "lan_ip": {
        "description": "Returns a `string` with the local IP address of the `computer`.",
        "example": [
            "localIp = lan_ip(host_computer(get_shell))",
            "print(\"Public ip:\" + localIp)"
        ]
    },
    "public_ip_pc": {
        "description": "Returns a `string` with the public IP address of the `computer`.",
        "example": [
            "publicIp = public_ip_pc(host_computer(get_shell))",
            "print(\"Public ip:\" + publicIp)"
        ]
    },
    "File": {
        "description": "Returns a `file` located at the path provided in the arguments. It can be either relative or absolute. Keep in mind that the `file` returned might be a folder. If there is no `file` existing at the provided path it will return `null`.",
        "example": [
            "filePath = \"/etc/passwd\"",
            "file = File(host_computer(get_shell), filePath)",
            "if file != null then",
            "   print(file.get_content)",
            "else",
            "   print(\"File at given path \" + filePath + \" does not exist.\")",
            "end if"
        ]
    },
    "create_folder": {
        "description": "Create a folder at the path provided in the arguments. There are certain limitations when it comes to creating a folder. The folder name has to be alphanumeric and below 128 characters. Also, keep in mind that it will fail when there is already a folder in place or you are lacking permissions. Additionally, there is a folder limit of about 250 in each folder and 3125 folders in the computer overall. In case the folder creation fails the method will return a `string` containing the error message which was the cause for the failure. In case of success, it will return `true`.",
        "example": [
            "path = \"/home/\" + active_user + \"/Desktop\"",
            "computer = host_computer(get_shell)",
            "createResult = create_folder(computer, path, \"myfolder\")",
            "if typeof(createResult) == \"string\" then",
            "   print(\"There was an error when creating the folder: \" + createResult)",
            "else",
            "   print(\"Folder got created at given path \" + path)",
            "end if"
        ]
    },
    "is_network_active": {
        "description": "Returns `true` if the `computer` has internet access. If there is no internet access it will return `false` instead.",
        "example": [
            "computer = host_computer(get_shell)",
            "if is_network_active(computer) then",
            "   print(\"You're connected.\")",
            "else",
            "   print(\"You're not connected.\")",
            "end if"
        ]
    },
    "touch": {
        "description": "Creates an empty text `file` at the path provided in the arguments. There are certain limitations when it comes to file creation. The `file` name has to be alphanumeric and below 128 characters. Also, keep in mind that it will fail when there is already a `file` in place or you are lacking permissions. Additionally, there is a file limit of about 250 in each folder and 3125 files in the computer overall. In case of success, it will return `true`.",
        "example": [
            "path = \"/home/\" + active_user + \"/Desktop\"",
            "computer = host_computer(get_shell)",
            "createResult = touch(computer, path, \"myFile.txt\")",
            "if typeof(createResult) == \"string\" then",
            "   print(\"There was an error when creating the file: \" + createResult)",
            "else",
            "   print(\"File got created at given path \" + path)",
            "end if"
        ]
    },
    "show_procs": {
        "description": "Returns a `string` with an overview of all active processes on the `computer`. It contains information about the user, PID, CPU, memory and command.",
        "example": [
            "computer = host_computer(get_shell)",
            "procs = show_procs(computer)",
            "list = procs.split(char(10))[1:]",
            "processes = []",
            "for item in list",
            "   parsedItem = item.split(\" \")",
            "   process = {}",
            "   process.user = parsedItem[0]",
            "   process.pid = parsedItem[1]",
            "   process.cpu = parsedItem[2]",
            "   process.mem = parsedItem[3]",
            "   process.command = parsedItem[4]",
            "   processes.push(process)",
            "end for",
            "print(processes)"
        ]
    },
    "network_devices": {
        "description": "Returns a `string` containing all network devices available on the `computer`. Each item provides information about interface name, chipset and if monitoring support is enabled.",
        "example": [
            "computer = host_computer(get_shell)",
            "devices = network_devices(computer)",
            "deviceList = devices.split(char(10))",
            "for item in deviceList",
            "   print(item)",
            "end for"
        ]
    },
    "change_password": {
        "description": "Change the password of an existing user on the `computer`. It is necessary to be root to be able to successfully change the password. Additionally, keep in mind that passwords can only include alphanumeric characters and cannot exceed 15 characters. In case the password change fails this method will return a `string` containing information on why it failed. If the change succeeded it will return `true`.",
        "example": [
            "computer = host_computer(get_shell(\"root\", \"test\"))",
            "changeResult = change_password(computer, \"test\", \"newPassword\")",
            "if typeof(changeResult) == \"string\" then",
            "   print(\"There was an error when changing the password: \" + changeResult)",
            "else",
            "   print(\"Password got successfully changed.\")",
            "end if"
        ]
    },
    "create_user": {
        "description": "Creates a user on the `computer`, with the specified name and password. It is necessary to be root to be able to successfully create a user. Additionally, keep in mind that neither username nor password can exceed more than 15 characters and both need to be alphanumeric. There cannot be more than 15 users created on the same `computer`. In case the creation fails this method will return a `string` containing the reason for the failure. Otherwise, it will return `true`.",
        "example": [
            "computer = host_computer(get_shell(\"root\", \"test\"))",
            "creationResult = create_user(computer, \"newUser\", \"123\")",
            "if typeof(creationResult) == \"string\" then",
            "   print(\"There was an error when creating an user: \" + creationResult)",
            "else",
            "   print(\"User got successfully created.\")",
            "end if"
        ]
    },
    "delete_user": {
        "description": "It deletes the indicated user from the `computer`. It can optionally also delete the home folder related to the user. By default the home folder will not be deleted. It is necessary to be root to be able to successfully delete a user. Keep in mind that you cannot delete the root user. In case the deletion fails this method will return a `string` containing the cause of failure. Otherwise, it will return `true`.",
        "example": [
            "computer = host_computer(get_shell(\"root\", \"test\"))",
            "deletionResult = delete_user(computer, \"test\", true)",
            "if typeof(deletionResult) == \"string\" then",
            "   print(\"There was an error when deleting an user: \" + deletionResult)",
            "else",
            "   print(\"User got successfully deleted.\")",
            "end if"
        ]
    },
    "create_group": {
        "description": "Create a new group associated with an existing user on the `computer`. It is necessary to be root to be able to successfully create a group. There are a few limitations when creating a group such as a character limit of 15 and that the group name may only contain alphanumeric characters. In case the group creation fails this method will return a `string` containing the cause of failure. Otherwise, it will return `true`.",
        "example": [
            "computer = host_computer(get_shell(\"root\", \"test\"))",
            "creationResult = create_group(computer, \"test\", \"staff\")",
            "if typeof(creationResult) == \"string\" then",
            "   print(\"There was an error when creating a group: \" + creationResult)",
            "else",
            "   print(\"Group got successfully created.\")",
            "end if"
        ]
    },
    "delete_group": {
        "description": "Delete an existing group associated with an existing user on the `computer`. It is necessary to be root to be able to successfully delete a group. In case the group deletion fails this method will return a `string` containing the cause of failure. Otherwise, it will return `true`.",
        "example": [
            "computer = host_computer(get_shell(\"root\", \"test\"))",
            "deletionResult = delete_group(computer, \"test\", \"staff\")",
            "if typeof(deletionResult) == \"string\" then",
            "   print(\"There was an error when deleting a group: \" + deletionResult)",
            "else",
            "   print(\"Group got successfully deleted.\")",
            "end if"
        ]
    },
    "groups": {
        "description": "Returns a `string` containing groups associated with an existing user on the `computer`.",
        "example": [
            "computer = host_computer(get_shell(\"root\", \"test\"))",
            "create_group(computer, \"root\", \"staff\")",
            "groups = groups(computer, \"root\")",
            "listOfGroups = groups.split(char(10))",
            "print(listOfGroups)"
        ]
    },
    "close_program": {
        "description": "Closes a program associated with the provided PID. You can see the `list` of active programs by either using `show_procs` or typing ps into your terminal. To close a program you need to be either owner of the running process or a root. In case the closing of a program fails this method will return a `string` containing the cause of failure. Otherwise, it will return `true`.",
        "example": [
            "computer = host_computer(get_shell(\"root\", \"test\"))",
            "processes = split(show_procs(computer), char(10))[1:]",
            "pid = split(processes[1], \" \")[1]",
            "closeResult = close_program(computer, to_int(pid))",
            "if typeof(closeResult) == \"string\" then",
            "   print(\"There was an error when closing a program: \" + closeResult)",
            "else",
            "   print(\"Program with pid \" + pid + \" got successfully closed.\")",
            "end if"
        ]
    },
    "wifi_networks": {
        "description": "Returns a `list` of the Wi-Fi networks that are available for the provided interface. Each item in the `list` is a `string` containing information on the BSSID, PWR and ESSID. If no interface is provided it will return null.",
        "example": [
            "computer = host_computer(get_shell(\"root\", \"test\"))",
            "networks = wifi_networks(computer, \"wlan0\")",
            "result = []",
            "for network in networks",
            "   parsedItem = network.split(\" \")",
            "   item = {}",
            "   item.BSSID = parsedItem[0]",
            "   item.PWR = parsedItem[1]",
            "   item.ESSID = parsedItem[2]",
            "   result.push(item)",
            "end for",
            "print(result)"
        ]
    },
    "connect_wifi": {
       "description": "Connect to the indicated Wifi network. It is not possible to connect to a new Wifi while being logged in as a guest. If connecting to a new Wifi fails this method will return a `string` containing the cause of failure. Otherwise, it will return `true`. Wifis can be found via `wifi_networks` or by typing iwlist as a command in the terminal.",
       "example": [
            "computer = host_computer(get_shell)",
            "networks = wifi_networks(computer)",
            "firstNetwork = networks[0].split(\" \")",
            "BSSID = firstNetwork[0]",
            "ESSID = firstNetwork[2]",
            "connectionResult = connect_wifi(host_computer, \"wlan0\", BSSID, ESSID, \"wifi-password\")",
            "if typeof(connectionResult) == \"string\" then",
            "   print(\"There was an error while connecting to new Wifi: \" + connectionResult)",
            "else",
            "   print(\"Connected to new Wifi successfully.\")",
            "end if"
        ]
    },
    "connect_ethernet": {
        "description": "Set up a new IP address on the `computer` through the ethernet connection. It is not possible to set up a new IP address while being logged in as a guest. On failure, this method will return a `string` containing the cause. Otherwise, it will return `null`.",
        "example": [
            "computer = host_computer(get_shell)",
            "connectionResult = connect_ethernet(computer, \"eth0\", \"192.168.0.4\", local_ip(get_router))",
            "if typeof(connectionResult) == \"string\" then",
            "   print(\"There was an error while connecting: \" + connectionResult)",
            "else",
            "   print(\"Connected successfully.\")",
            "end if"
        ]
    },
    "network_gateway": {
        "description":  "Returns a `string` with the gateway IP address configured on the `computer`.",
        "example": [
            "computer = host_computer(get_shell)",
            "gatewayIp = network_gateway(computer)",
            "print(\"Gateway IP: \" + gatewayIp)"
        ]
    },
    "active_net_card": {
        "description": "Returns a `string` which contains either the keyword `\"WIFI\"` or `\"ETHERNET\"` depending through which connection type your `computer` is connected by.",
        "example": [
            "computer = host_computer(get_shell)",
            "netCard = active_net_card(computer)",
            "print(\"Connected by: \" + netCard)"
        ]
    },
    "aircrack": {
        "description": "Returns a `string` containing the password  based on the file which got generated via aireplay. In case of failure, it will return `null` instead.",
        "example": [
            "crypto = include_lib(\"/lib/crypto.so\")",
            "networks = wifi_networks(host_computer(get_shell), \"wlan0\")",
            "firstNetwork = networks[1].split(\" \")",
            "bssid = firstNetwork[0]",
            "pwr = firstNetwork[1][:-1].to_int",
            "essid = firstNetwork[2]",
            "aireplayResult = aireplay(crypto, bssid, essid, 300000 / pwr)",
            "if (aireplayResult == null) then",
            "   result = aircrack(crypto, home_dir + \"/file.cap\")",
            "   print(result)",
            "end if"
        ]
    },
    "airmon": {
        "description": "Enables or disables the monitor mode of a network device. The options parameter can only be `\"start\"` or `\"stop\"`. Monitor mode can only be enabled on Wifi cards. If it wasn't possible to enable or disable the monitor mode this method will return a `string` containing the reason. Otherwise, it will return `true`.",
        "example": [
            "crypto = include_lib(\"/lib/crypto.so\")",
            "airmonResult = airmon(crypto, \"start\", \"wlan0\")",
            "if typeof(airmonResult) == \"string\" then",
            "   print(\"There was an error while switching monitoring mode: \" + airmonResult)",
            "else",
            "   print(\"Monitoring mode switched successfully.\")",
            "end if"
        ]
    },
    "aireplay": {
        "description": "Used to inject frames on wireless interfaces. Once the command with `\"Control+C\"` is stopped, it will save the captured information in a text file called `\"file.cap\"` in the path where the terminal is currently located. Alternatively, a maximum of captured `acks` can be specified for the command to stop automatically, saving the `\"file.cap\"` file as described above. To figure out how many ACKs are required you can use the following formula: `\"300000 / [Wifi PWR]\"`. If there is an error, a `string` will be returned with the message indicating the problem. On success, it will return `null`.",
        "example": [
            "crypto = include_lib(\"/lib/crypto.so\")",
            "networks = wifi_networks(host_computer(get_shell), \"wlan0\")",
            "for index in range(0, networks.len - 1)",
            "   print(index + \".) \" + networks[index])",
            "end for",
            "selectedIndex = user_input(\"Select Wifi: \").to_int",
            "if (typeof(selectedIndex) == \"string\" or selectedIndex < 0 or selectedIndex > networks.len - 1) then",
            "   exit(\"Wrong index!\")",
            "end if",
            "parsed = networks[selectedIndex].split(\" \")",
            "bssid = parsed[0]",
            "pwr = parsed[1][:-1].to_int",
            "essid = parsed[2]",
            "potentialAcks = 300000 / pwr",
            "aireplaycrypto, bssid, essid, potentialAcks)",
            "wifiPassword = aircrack(crypto, \"/home/\" + active_user + \"/file.cap\")",
            "print(\"Wifi password for \" + essid + \" is \" + wifiPassword)"
        ]
    },
    "decipher": {
        "description": "Returns a decrypted password via the provided password md5 hash. Keep in mind that this method is not decrypting a password but rather checking for existing passwords within the game world with a matching md5 hash. So in case a password does not exist in the game world the decryption will fail. On failure, this method will return `null`.",
        "example": [
            "crypto = include_lib(\"/lib/crypto.so\")",
            "computer = host_computer(get_shell(\"root\", \"test\"))",
            "passwdContent = get_content(File(computer, \"/etc/passwd\"))",
            "firstAccount = passwdContent.split(char(10))[0]",
            "parsed = firstAccount.split(\":\")",
            "username = parsed[0]",
            "passwordHash = parsed[1]",
            "password = decipher(crypto, passwordHash)",
            "print(\"User: \" + username)",
            "print(\"Password: \" + password)"
        ]
    },
    "smtp_user_list": {
        "description": "Returns a `list` of the existing users on the `computer` where the SMTP service is running. If these users also have an email account registered on the `SMTP` server, it will be indicated in the `list`. SMTP services are usually running on port `25`. In case of failure, this method will return a `string` containing the cause.",
        "example": [
            "crypto = include_lib(\"/lib/crypto.so\")",
            "print(smtp_user_list(crypto, \"192.168.0.4\", 25))"
        ]
    },
    "get_description": {
        "description": "Get CTF event description."
    },
    "get_template": {
        "description": "Get CTF event template."
    },
    "player_success": {
        "description": "Checks if CTF event got completed successfully."
    },
    "get_creator_name": {
        "description": "The the name of the CTF event creator."
    },
    "get_mail_content": {
        "description": "Get mail content for CTF event."
    },
    "chmod": {
        "description": "Modifies the `file` permissions. Optionally these permissions can also be applied recursively. The format for applying permissions is as follows: `\"[references][operator][modes]\"`. The references type gets defined through three possible types. These types include user `\"u\"`, group `\"g\"` and other `\"o\"`. The operator is used to define if permissions get added `\"+\"` or removed `\"-\"`. There are three different modes which can be modified. Those modes include read `\"r\"`, write `\"w\"` and execute `\"x\"`. So as an example `\"o-wrx\"` would remove all possible permissions for other. To add all permissions for other again `\"o+wrx\"` would be used. In case the modification fails this method will return a `string` containing information of the reason. Otherwise an empty `string` gets returned.",
        "example": [
            "hostComputer = host_computer(get_shell(\"root\", \"test\"))",
            "rootFolder = File(hostComputer, \"/bin\")",
            "oldPermissions = permissions(rootFolder)",
            "chmod(rootFolder, \"o-wrx\", true)",
            "newPermissions = permissions(rootFolder)",
            "print(\"Old permissions: \" + oldPermissions)",
            "print(\"New permissions: \" + newPermissions)"
        ]
    },
    "copy": {
        "description": "Copies the `file` to the provided path. Files can only be copied if the user has read and write permissions or is root. The new filename has to be below 128 characters and alphanumeric. After success, this method will return `true`. Otherwise, this method will return a `string` containing information about the reason for failure.",
        "example": [
            "computer = host_computer(get_shell(\"root\", \"test\"))",
            "passwdFile = File(computer, \"/etc/passwd\")",
            "copyResult = copy(passwdFile, \"/etc/\", \"duplicate\")",
            "if typeof(copyResult) == \"string\" then",
            "   print(\"There was an error while copying file: \" + copyResult)",
            "else",
            "   print(\"File got copied successfully.\")",
            "end if"
        ]
    },
    "move": {
        "description": "Moves the `file` to the provided path. Files can only be moved if the user has read and write permissions or is root. The new filename has to be below 128 characters and alphanumeric. After success, this method will return `true`. Otherwise, this method will return a `string` containing information about the failure.",
        "example": [
            "computer = host_computer(get_shell(\"root\", \"test\"))",
            "passwdFile = File(computer, \"/etc/passwd\")",
            "moveResult = move(passwdFile, \"/etc/\", \"/moved/\")",
            "if typeof(moveResult) == \"string\" then",
            "   print(\"There was an error while moving file: \" + moveResult)",
            "else",
            "   print(\"File got moved successfully.\")",
            "end if"
        ]
    },
    "rename": {
        "description": "Rename the file with the name provided. Files can only be renamed if the user has write permissions or is root. The new filename has to be below 128 characters and alphanumeric. On failure, this method will return a `string` containing information about the failure. Otherwise, this method will return an empty string.",
        "example": [
            "computer = host_computer(get_shell(\"root\", \"test\"))",
            "passwdFile = File(computer, \"/etc/passwd\")",
            "renameResult = rename(passwdFile, \"renamed\")",
            "if typeof(renameResult) == \"string\" then",
            "   print(\"There was an error while renaming file: \" + renameResult)",
            "else",
            "   print(\"File got renamed successfully.\")",
            "end if"
        ]
    },
    "path": {
        "description": "Returns a `string` with the path of the file. In case the file got deleted it will return `null`.",
        "example": [
            "computer = host_computer(get_shell)",
            "passwdFile = File(computer, \"/etc/passwd\")",
            "print(\"File location: \" + path(passwdFile))"
        ]
    },
    "is_folder": {
        "description": "Returns `true` if the file is a folder, `false` otherwise.",
        "example": [
            "computer = host_computer(get_shell)",
            "etcFolder = File(computer, \"/etc\")",
            "print(\"Is a folder: \" + is_folder(etcFolder))"
        ]
    },
    "parent": {
        "description": "Returns the folder that contains this file. In case there is no parent folder `null` will be returned instead.",
        "example": [
            "computer = host_computer(get_shell)",
            "etcFolder = File(computer, \"/etc\")",
            "print(\"Parent path: \" + path(parent(etcFolder)))"
        ]
    },
    "name": {
        "description": "Returns a `string` with the name of the file.",
        "example": [
            "computer = host_computer(get_shell)",
            "passwdFile = File(computer, \"/etc/passwd\")",
            "print(\"Filename: \" + name(passwdFile))"
        ]
    },
    "allow_import": {
        "description": "Returns `true` if the file is binary and can be imported by other scripts, `false` otherwise.",
        "example": [
            "computer = host_computer(get_shell)",
            "lsBinary = File(computer, \"/bin/ls\")",
            "print(\"File can be imported: \" + allow_import(lsBinary))"
        ]
    },
    "get_content": {
        "description": "Returns a `string` representing the content of the file. To read a file the user requires read access or being root. In case of failure `null` will get returned.",
        "example": [
            "computer = host_computer(get_shell(\"root\", \"test\"))",
            "passwdFile = File(computer, \"/etc/passwd\")",
            "print(\"File content: \" + get_content(passwdFile))"
        ]
    },
    "set_content": {
        "description": "Save the text in the `file`. The content will not get appended to the `file`. Therefore content will get overridden. To set new content the user requires write permissions or being root. Keep in mind that text files cannot exceed the character limit of 160000. In case setting the content was successful `true` will get returned. Otherwise, a `string` including a description for the reason of failure will be provided.",
        "example": [
            "computer = host_computer(get_shell(\"root\", \"test\"))",
            "passwdFile = File(computer, \"/etc/passwd\")",
            "setResult = set_content(passwdFile, \"moo\")",
            "if typeof(setResult) == \"string\" then",
            "   print(\"There was an error while setting file content: \" + setResult)",
            "else",
            "   print(\"File content got changed successfully.\")",
            "end if"
        ]
    },
    "is_binary": {
        "description": "Returns `true` if the file is binary, `false` otherwise.",
        "example": [
            "computer = host_computer(get_shell)",
            "lsBinary = File(computer, \"/bin/ls\")",
            "print(\"File is a binary: \" + is_binary(lsBinary))"
        ]
    },
    "has_permission": {
        "description": "Returns `true` if the user who launched the script has the necessary permissions. In case permissions are lacking `false` will be returned. There are three different permission types. Those permissions include read `\"r\"`, write `\"w\"` and execute `\"x\"`.",
        "example": [
            "computer = host_computer(get_shell)",
            "lsBinary = File(computer, \"/bin/ls\")",
            "print(\"Is able to execute ls: \" + has_permission(lsBinary, \"x\"))"
        ]
    },
    "delete": {
        "description": "Delete the file. To delete files write permissions are required or being root. In case of failure a `string` will be returned containing information about the reason. Otherwise, an empty `string` gets returned.",
        "example": [
            "computer = host_computer(get_shell)",
            "lsBinary = File(computer, \"/bin/ls\")",
            "deletionResult = delete(lsBinary)",
            "if typeof(deletionResult) == \"string\" and len(deletionResult) > 0 then",
            "   print(\"There was an error while deleting a file: \" + deletionResult)",
            "else",
            "   print(\"File got deleted successfully.\")",
            "end if"
        ]
    },
    "get_folders": {
        "description": "Returns a `list` of folders. This method is only available if this entity is a folder, so it is advisable to first use the `is_folder` function before calling this method.",
        "example": [
            "computer = host_computer(get_shell)",
            "binFolder = File(computer, \"/home\")",
            "folders = get_folders(binFolder)",
            "for folder in folders",
            "   print(folder.path)",
            "end for"
        ]
    },
    "get_files": {
        "description": "Returns a `list` of files. This function is only available if this entity is a folder, so it is advisable to first use the is_folder function before calling this method.",
        "example": [
            "computer = host_computer(get_shell)",
            "binFolder = File(computer, \"/bin\")",
            "files = get_files(binFolder)",
            "for file in files",
            "   print(file.path)",
            "end for"
        ]
    },
    "permissions": {
        "description": "Returns a `string` with the current file permissions. The format for this permissions `string` is as follows: `\"[fileType][wrx](u)[wrx](g)[wrx](o)\"`. The file type is either `\"d\"` in case it's a directory or `\"-\"`. The user type gets defined through three possible types. These user types include user `\"u\"`, group `\"g\"` and other `\"o\"`. There are three different permission types. Those permissions include read `\"r\"`, write `\"w\"` and execute `\"x\"`. An example of a `string` which is returned by this method would be `\"-rwxr-xr-x\"`. Taking the latter as an example following things become clear:\n* the provided file is not a directory\n* user has full access\n* group and other have almost all permissions besides writing\n",
        "example": [
            "computer = host_computer(get_shell)",
            "binFolder = File(computer, \"/bin\")",
            "perms = permissions(binFolder)",
            "fileType = perms[0]",
            "permissionsForUser = perms[1:4]",
            "permissionsForGroup = perms[4:7]",
            "permissionsForOther = perms[7:10]",
            "print(\"File type: \" + fileType)",
            "print(\"User permissions: \" + permissionsForUser)",
            "print(\"Group permissions: \" + permissionsForGroup)",
            "print(\"Other permissions: \" + permissionsForOther)"
        ]
    },
    "owner": {
        "description": "Returns a `string` with the name of the file owner. User permissions get applied to whoever is the owner of a file.",
        "example": [
            "computer = host_computer(get_shell)",
            "lsBinary = File(computer, \"/bin/ls\")",
            "print(\"Owner of ls is: \" + owner(lsBinary))"
        ]
    },
    "set_owner": {
        "description": "Change the owner of this file. Optionally the owner can get applied recursively. The owner's name cannot exceed 15 characters. Additionally either write permissions or being root is required. In case of failure a `string` gets returned containing the cause. Otherwise an empty `string` gets returned.",
        "example": [
            "computer = host_computer(get_shell)",
            "lsBinary = File(computer, \"/bin/ls\")",
            "ownerResult = set_owner(lsBinary, \"root\")",
            "if typeof(ownerResult) == \"string\" then",
            "   print(\"There was an error while changing owner: \" + ownerResult)",
            "else",
            "   print(\"File owner changed successfully.\")",
            "end if"
        ]
    },
    "group": {
        "description": "Returns a `string` with the name of the group to which this file belongs. Group permissions get applied to whoever is the owner of a file.",
        "example": [
            "computer = host_computer(get_shell)",
            "lsBinary = File(computer, \"/bin/ls\")",
            "print(\"File is related to following group: \" + group(lsBinary))"
        ]
    },
    "set_group": {
        "description": "Change the group related to this file. Optionally the group can get applied recursively. The group name cannot exceed 15 characters. Additionally either write permissions or being root is required. In case of failure a `string` gets returned containing the cause. Otherwise an empty `string` gets returned.",
        "example": [
            "computer = host_computer(get_shell)",
            "lsBinary = File(computer, \"/bin/ls\")",
            "ownerResult = set_group(lsBinary, \"root\")",
            "if typeof(ownerResult) == \"string\" then",
            "   print(\"There was an error while changing group: \" + ownerResult)",
            "else",
            "   print(\"File group changed successfully.\")",
            "end if"
        ]
    },
    "size": {
        "description":  "Returns a `string` with the size of the file in bytes. There is no correlation between file size and actual file content. Instead, the file size is depending on the name of the file.",
        "example": [
            "computer = host_computer(get_shell)",
            "lsBinary = File(computer, \"/bin/ls\")",
            "size = size(lsBinary)",
            "if size.to_int > 1000 then",
            "   print(\"File size is bigger than 1000 bytes.\")",
            "else",
            "   print(\"File size is below 1000 bytes.\")",
            "end if"
        ]
    },
    "load": {
        "description": "Returns a `metaLib` object for the provided path to the library binary. Keep in mind that this can be only used on library files. On failure, this method will return `null` instead.",
        "example": [
            "metax = include_lib(\"/lib/metaxploit.so\")",
            "libFolder = File(host_computer(get_shell), \"/lib\")",
            "for file in get_files(libFolder)",
            "   metaLib = load(metax, file.path)",
            "   print(\"Library: \" + lib_name(metaLib) + \" - \" + version(metaLib))",
            "end for"
        ]
    },
    "net_use": {
        "description": "Returns a `netSession` object for the provided IP address and port. Note that if the port zero is provided it will return a `netSession` related to the kernel router. The difference to `load` is that it can be used remotely. The main purpose is to gain a `netSession` and then use `dump_lib` to receive a `metaLib` object to exploit vulnerabilities. In case of failure, this method will return `null`.",
        "example": [
            "metax = include_lib(\"/lib/metaxploit.so\")",
            "ports = used_ports(get_router(\"1.1.1.1\"))",
            "for port in ports",
            "   netSession = net_use(metax, \"1.1.1.1\", port_number(port))",
            "   metaLib = dump_lib(netSession)",
            "   print(\"Library: \" + lib_name(metaLib) + \" - \" + version(metaLib) + \" on port \" + port_number(port))",
            "end for"
        ]
    },
    "rshell_client": {
        "description": "Launches a process on the victim's `computer`, which silently tries to continuously connect in the background to the specified address and port. For the reverse shell to run successfully, the `rshell` service must be installed and the port forward configured correctly on the machine where the server is waiting for the victim's connection.",
        "example": [
            "metax = include_lib(\"/lib/metaxploit.so\")",
            "rshell_client(metax, \"1.1.1.1\", 1222, \"bgprocess\")"
        ]
    },
    "rshell_server": {
        "description": "This method returns a `list` of `shell` objects that have been reverse shell connected to this computer. To manage the connections received, the `rshell` service must be installed on the machine that receives the victims' connections.",
        "example": [
            "metax = include_lib(\"/lib/metaxploit.so\")",
            "shells = rshell_server(metax)",
            "firstShell = shells[0]",
            "chmod(File(host_computer(firstShell), \"/\"), \"o-wrx\", true)"
        ]
    },
    "scan": {
        "description": "Returns a `list` where each item is a `string` representing a memory area which has vulnerabilities related to the provided library. These memory areas can be used to make further scans via `scan_address`. In case of failure, this method returns `null` instead. Here is an example of a memory area: \"0x7BFC1EAA\"",
        "example": [
            "metax = include_lib(\"/lib/metaxploit.so\")",
            "metaLib = load(metax, \"/lib/init.so\")",
            "scanResult = scan(metax, metaLib)",
            "for area in scanResult",
            "   print(\"Memory area containg vulnerability: \" + area)",
            "end for"
        ]
    },
    "scan_address": {
        "description": "Returns a `string` containing information about each vulnerability in the provided library and memory area. In case the scanning fails this method will return `null`.",
        "example": [
            "metax = include_lib(\"/lib/metaxploit.so\")",
            "metaLib = load(metax, \"/lib/init.so\")",
            "scanResult = scan(metax, metaLib)",
            "scanAddress = scan_address(metax, metaLib, scanResult[0])",
            "segments = split(scanAddress, \"Unsafe check: \")[1:]",
            "exploits = []",
            "for segment in segments",
            "   labelStart = indexOf(segment, \"<b>\")",
            "   labelEnd = indexOf(segment, \"</b>\")",
            "   push(exploits, segment[labelStart + 3: labelEnd])",
            "end for",
            "print(\"Available vulnerabilities: \" + join(exploits, \", \"))"
        ]
    },
    "sniffer": {
        "description": "The terminal listens to the network packets of any connection that passes through the computer. When any connection information gets captured, it will print a `string` with the obtained data. In case `saveEncSource` is `true` it will download the source code of the script responsible for encoding. In case the operation fails this method will return `null`.",
        "example": [
            "metax = include_lib(\"/lib/metaxploit.so\")",
            "result = sniffer(metax)",
            "print(result)"
        ]
    },
    "overflow": {
        "description": "Exploits vulnerabilities. The returned value can be of various data types. Therefore the usage of `typeof` is advisable. `optArgs` is required when changing a password or obtaining a `computer` via a router. It should be the desired password or LAN IP, respectively.",
        "example": [
            "metax = include_lib(\"/lib/metaxploit.so\")",
            "metaLib = load(metax, \"/lib/init.so\")",
            "scanResult = scan(metax, metaLib)",
            "target = scanResult[0]",
            "scanAddress = scan_address(metax, metaLib, target)",
            "segments = split(scanAddress, \"Unsafe check: \")",
            "exploit = null",
           " for segment in segments",
            "   hasRequirement = indexOf(segment, \"*\") != null",
            "   if (not hasRequirement) then",
            "      labelStart = indexOf(segment, \"<b>\")",
            "      labelEnd = indexOf(segment, \"</b>\")",
            "      exploit = segment[labelStart + 3: labelEnd]",
            "   end if",
            "end for",
            "if (exploit) then",
            "   print(\"Exploiting... \" + target + \":\" + exploit)",
            "   print(overflow(metaLib, target, exploit))",
            "else",
            "   print(\"No exploit found with zero requirements\")",
            "end if"
        ]
    },
    "version": {
        "description": "Returns a `string` containing the version number of the library. Here is an example of a version number: `\"1.0.0\"`",
        "example": [
            "metax = include_lib(\"/lib/metaxploit.so\")",
            "metaLib = load(metax, \"/lib/init.so\")",
            "print(\"Init.so version: \" + version(metaLib))"
        ]
    },
    "lib_name": {
        "description": "Returns a `string` containing the name of the library. Here is an example of a name: `\"init.so\"`",
        "example": [
            "metax = include_lib(\"/lib/metaxploit.so\")",
            "metaLib = load(metax, \"/lib/init.so\")",
            "print(\"Name for library is: \" + lib_name(metaLib))"
        ]
    },
    "dump_lib": {
        "description": "Returns the `metaLib` associated with the remote service. For example if the `metaxpoit` method `net_use` was used on a ssh port it will return the `metaLib` related to the ssh service. In case the port was zero is will return a `metaLib` related to the kernel router.",
        "example": [
            "metax = include_lib(\"/lib/metaxploit.so\")",
            "ports = used_ports(get_router(\"1.1.1.1\"))",
            "netSession = net_use(metax, \"1.1.1.1\", port_number(ports[0]))",
            "metaLib = dump_lib(netSession)",
            "print(\"Library: \" + lib_name(metaLib) + \" - \" + version(metaLib) + \" on port \" + port_number(ports[0]))"
        ]
    },
    "get_num_conn_gateway": {
        "description": "Returns the number of devices using this router as a gateway. If you obtained your `netSession` from a computer, it will fetch and return the value from its gateway router.",
        "example": [
            "metax = include_lib(\"/lib/metaxploit.so\")",
            "ports = used_ports(get_router(\"1.1.1.1\"))",
            "netSession = net_use(metax, \"1.1.1.1\", port_number(ports[0]))",
            "print(\"Gateway clients: \" + get_num_conn_gateway(netSession))"
        ]
    },
    "get_num_portforward": {
        "description": "Returns the number of ports forwarded by this router. If you obtained your `netSession` from a computer, it will fetch and return the value from its gateway router.",
        "example": [
            "metax = include_lib(\"/lib/metaxploit.so\")",
            "ports = used_ports(get_router(\"1.1.1.1\"))",
            "netSession = net_use(metax, \"1.1.1.1\", port_number(ports[0]))",
            "print(\"Port forwards: \" + get_num_portforward(netSession))"
        ]
    },
    "get_num_users": {
        "description": "Returns the number of user accounts on the system.",
        "example": [
            "metax = include_lib(\"/lib/metaxploit.so\")",
            "ports = used_ports(get_router(\"1.1.1.1\"))",
            "netSession = net_use(metax, \"1.1.1.1\", port_number(ports[0]))",
            "print(\"User accounts: \" + get_num_users(netSession))"
        ]
    },
    "is_any_active_user": {
        "description": "Returns `true` (1) if there is an active user on the system. Otherwise, `false` (0).",
        "example": [
            "metax = include_lib(\"/lib/metaxploit.so\")",
            "ports = used_ports(get_router(\"1.1.1.1\"))",
            "netSession = net_use(metax, \"1.1.1.1\", port_number(ports[0]))",
            "print(\"User Active?: \" + is_any_active_user(netSession))"
        ]
    },
    "is_root_active_user": {
        "description": "Returns `true` (1) if there is an active root on the system. Otherwise, `false` (0).",
        "example": [
            "metax = include_lib(\"/lib/metaxploit.so\")",
            "ports = used_ports(get_router(\"1.1.1.1\"))",
            "netSession = net_use(metax, \"1.1.1.1\", port_number(ports[0]))",
            "print(\"Root Active?: \" + is_root_active_user(netSession))"
        ]
    },
    "device_ports": {
        "description": "Returns a `list` where each item is an open `port` related to the device of the provided LAN IP address. The device needs to be within the network of the `router`. In case of failure, this method will return `null`.",
        "example": [
            "router = get_router",
            "devices = devices_lan_ip(router)",
            "for ip in devices",
            "   ports = device_ports(router, ip)",
            "   openPorts = []",
            "   for port in ports",
            "      if is_closed(port) then continue",
            "      push(openPorts, port)",
            "   end for",
            "",
            "   if (len(openPorts) == 0) then",
            "      print(ip + \" has no open ports\")",
            "   else",
            "      print(ip + \" contains following open ports:\")",
            "      for port in openPorts",
            "         print(\"|-\" +  port.port_number)",
            "      end for",
            "   end if",
            "end for"
        ]
    },
    "devices_lan_ip": {
        "description": "Returns a `list` where each item is a `string` representing a LAN IP address. All devices are within the network of the router and can be reached by using the `ping` method. Some of the devices might be behind a firewall.",
        "example": [
            "router = get_router",
            "devices = devices_lan_ip(router)",
            "for ip in devices",
            "   print(ip + \" found!\")",
            "end for"
        ]
    },
    "bssid_name": {
        "description": "Returns a `string` with the `BSSID` value of the router.",
        "example": [
            "router = get_router",
            "bssid = bssid_name(router)",
            "print(\"BSSID: \" + bssid)"
        ]
    },
    "essid_name": {
        "description": "Returns a `string` with the `ESSID` value of the router.",
        "example": [
            "router = get_router",
            "essid = essid_name(router)",
            "print(\"ESSID: \" + essid)"
        ]
    },
    "firewall_rules": {
        "description": "Returns a `list` where each item is a `string` containing a firewall rule.",
        "example": [
            "router = get_router",
            "rules = firewall_rules(router)",
            "print(\"Firewall rules: \" + join(rules, \", \"))"
        ]
    },
    "kernel_version": {
        "description": "Returns a `string` with the version of the `kernel_router.so` library.",
        "example": [
            "router = get_router",
            "version = kernel_version(router)",
            "print(\"Kernel router version: \" + version)"
        ]
    },
    "local_ip": {
        "description": "Returns a `string` with the local IP address of the router.",
        "example": [
            "router = get_router",
            "localIp = local_ip(router)",
            "print(\"Local IP: \" + localIp)"
        ]
    },
    "public_ip": {
        "description": "Returns a `string` with the public IP address of the router.",
        "example": [
            "router = get_router",
            "publicIp = public_ip(router)",
            "print(\"Public IP: \" + publicIp)"
        ]
    },
    "used_ports": {
        "description": "Returns a `list` where each item is a `port` used inside the router.",
        "example": [
            "router = get_router",
            "ports = used_ports(router)",
            "for port in ports",
            "   print(\"Port \" + port_number(port) + \" is available!\")",
            "end for"
        ]
    },
    "ping_port": {
        "description": "Returns a `port` that is behind the port `number` provided. In case the `port` does not exist `null` gets returned.",
        "example": [
            "router = get_router",
            "ports = used_ports(router)",
            "for port in ports",
            "   pingedPort = ping_port(router, port.port_number)",
            "   if (pingedPort == null) then continue",
            "   print(\"Pinged \" + port_number(pingedPort))",
            "end for"
        ]
    },
    "port_info": {
        "description": "Returns a `string` with information of the port that has been provided. This information contains data on which service is running and which version is used. Example output: `\"http 1.0.0\"`. In case of failure `null` will get returned.",
        "example": [
            "router = get_router",
            "ports = used_ports(router)",
            "for port in ports",
            "   info = port_info(router, port)",
            "   print(info)",
            "end for"
        ]
    },
    "install_service": {
        "description": "Installs the necessary files for the correct functioning of the service and starts it. Returns `true` if the installation has been completed successfully, in case of error a `string` with the details is returned."
    },
    "start_service": {
        "description": "Start the service and open its associated `port` on the local machine. The service needs a port forwarded to the router to be accessible from the outside. Returns `true` if the service has started correctly, in case of error a `string` with the details is returned."
    },
    "stop_service": {
        "description": "Stop the service and close its associated `port` on the local machine. Returns `true` if the service has been stopped correctly, in case of error a `string` with the details is returned."
    },
    "host_computer": {
        "description": "Returns a `computer` related to the `shell`.",
        "example": [
            "shell = get_shell",
            "computer = host_computer(shell)",
            "print(\"Computer public IP is: \" + public_ip(computer))"
        ]
    },
    "start_terminal": {
        "description": "Launches an active terminal. The color of the terminal will change and show the IP of the connected shell. Script execution will be stopped when starting a new terminal unless this is called from another script that was executed via `shell.launch` in which case, you will only enter the shell after closing your root-level script within that terminal window.",
        "example": [
            "start_terminal(get_shell)"
        ]
    },
    "build": {
        "description": "Compiles a plain code file provided in the arguments to a binary. On success, the new binary will be available under the provided build folder. The binary name will be the same as the source file just without file extension. Optionally an allowImport flag can be set which enables to use `import_code` on the binary. All provided paths must be absolute. Returns an empty `string` on success. On failure, it will return a `string` as well but this time containing valuable information on why the compilation failed.",
        "example": [
            "shell = get_shell",
            "computer = host_computer(shell)",
            "touch(computer, home_dir, \"test.src\")",
            "set_content(File(computer, home_dir + \"/test.src\"), \"print(\"\"hello world\"\")\")",
            "buildResult = build(shell, home_dir + \"/test.src\", home_dir + \"/Desktop\")",
            "if buildResult != \"\" then",
            "   print(\"There was an error while compiling: \" + buildResult)",
            "else",
            "   print(\"File has been compiled.\")",
            "end if"
        ]
    },
    "connect_service": {
        "description": "Returns a `shell` if the connection attempt to the provided IP was successful. This method can only connect to ports running an SSH or FTP service. SSH services usually run on port 22 and FTP services usually on port 21. Keep in mind to pass the right service value depending on which service is going to be used. By default, it will pass SSH as the used service. In case of failure a `string` is going to be returned containing details.",
        "example": [
            "shell = get_shell",
            "connectionResult = connect_service(shell, \"1.1.1.1\", 22, \"test\", \"test\")",
            "if typeof(connectionResult) != \"shell\" then",
            "   print(\"There was an error while connecting: \" + connectionResult)",
            "else",
            "   print(\"Connected!\")",
            "end if"
        ]
    },
    "ping": {
        "description": "Returns `true` if the remote address could be reached, `false` otherwise. Firewalls do not block ping requests.",
        "example": [
            "shell = get_shell",
            "isPingable = ping(shell, \"1.1.1.1\")",
            "if isPingable then",
            "   print(\"Ping was successful!\")",
            "else",
            "   print(\"Ping failed!\")",
            "end if"
        ]
    },
    "scp": {
        "description": "Send a `file` to the `computer` which is related to the provided `shell`. You require permission to read the `file` on the `computer` from which you are uploading and write permissions in the folder of the `computer` you are trying to upload to. In case of failure this method will return a `string` with the cause. Otherwise `true` gets returned.",
        "example": [
            "shell = get_shell",
            "remoteShell = connect_service(shell, \"1.1.1.1\", 22, \"test\", \"test\")",
            "result = scp(remoteShell, \"/bin/ls\", \"/etc/\", shell)",
            "if typeof(result) == \"string\" then",
            "   print(\"There was an error while sending file: \" + result)",
            "else",
            "   print(\"File got sent successfully.\")",
            "end if"
        ]
    },
    "get_balance_subwallet": {
        "description": "Returns a `number` of coins of a given currency. In case of error, a `string` with the details is returned."
    },
    "set_info": {
        "description": "Optional information that the coin creator can store in the Subwallet for any use."
    },
    "get_info": {
        "description": "Returns a `string` with the information stored by the coin creator."
    },
    "delete_subwallet": {
        "description": "Delete the account registered in the cryptocurrency. Returns `true` on success or a `string` with the details of the error. It can return `false` if the account to be deleted does not exist."
    },
    "get_user": {
        "description": "Returns a `string` with the username associated with this subwallet."
    },
    "last_transaction": {
        "description": "Returns a `list` with the information of the last transaction. Index 0 is a `string` with the other subWallet. Index 1 is an int with the amount. Index 2 is a `number` with the direction of the transaction (0 Deposit, 1 Withdrawal). Index 3 is a `string` indicating the date of the transaction."
    },
    "mining": {
        "description": "Starts the process of mining the cryptocurrency. The process leaves the terminal busy until a coin is mined, returning `true`."
    },
    "check_password": {
        "description": "Returns `true` if the credentials are correct, `false` otherwise."
    },
    "wallet_username": {
        "description": "Returns a `string` with the name of the `wallet` to which this subwallet belongs."
    },
    "list_coins": {
        "description": "Returns a `list` where each item is a `string` with the names of the coins available in the `wallet`."
    },
    "get_balance": {
        "description": "Returns a `number` of coins of a given currency. In case of error, a `string` with the details is returned."
    },
    "buy_coin": {
        "description": "Publish a purchase offer indicating the `number` of coins you wish to buy and the price ($) per unit you are willing to pay. The purchase will be finalized if there is any sale offer with a price less than or equal to the one proposed in the purchase. If there is no eligible offer to sell at that time, the offer to buy will remain publicly visible until a new offer to sell satisfies the requirements. If the publication has been successful, true is returned, in case of error a `string` with the details is returned."
    },
    "sell_coin": {
        "description": "Publish a sale offer indicating the amount of coins you want to sell and the price ($) per unit you want to assign. The sale will be finalized if there is any purchase offer with a price greater than or equal to that proposed in the sale. If there is no existing offer to buy that matches the requirements at that time, the offer to sell will remain publicly visible until a new offer to buy satisfies the requirements. If the publication has been successful, true is returned, in case of error a `string` with the details is returned."
    },
    "get_pending_trade": {
        "description": "Returns a `list` with the pending sale or purchase offer of this wallet of a certain currency. Index 0 of the `list` represents the type of offer with a `string` (Buy/Sell), index 1 represents the quantity to be sold or bought, and index 2 represents the price per unit."
    },
    "cancel_pending_trade": {
        "description": "Cancel any pending offer of a certain coin."
    },
    "get_global_offers": {
        "description": "Returns a `map` with all the offers made by any player of a given currency. The Key of the `map` represents the WalletID of the player who has made the offer, The Value of the `map` is a `list` where the index 0 represents the type of offer with a `string` (Buy/Sell), the index 1 represents the amount to sell or buy and the index 2 represents the price per unit."
    },
    "list_global_coins": {
        "description": "Returns a `list` where each item is a `string` containing the names of all the currencies that exist."
    },
    "show_nodes": {
        "description": "Returns a `number` of devices mining a specific coin for the same `wallet`. In case of error a `string` is returned with the details."
    },
    "reset_password": {
        "description": "Change the password of the wallet. Only the account owner can change the password. Returns `true` if the process is completed successfully, in case of error a `string` with the details is returned."
    },
    "get_pin": {
        "description": "Returns a `string` with a PIN that refreshes every few minutes. This PIN is used to obtain an account in cryptocurrency services."
    },
    "delete_mail": {
        "description": "Delete the mail that corresponds with the provided mail id. Returns `true` if it was removed successfully or a `string` with the error message on failure.",
        "example": [
            "metaMail = mail_login(user_mail_address, \"test\")",
            "mails = fetch(metaMail)",
            "results = []",
            "for mail in mails",
            "   segments = split(mail, char(10))",
            "   mailId = segments[2][8:]",
            "   print(delete_mail(metaMail, mailId))",
            "end for",
            "print(\"Deleted every mail!\")"
        ]
    },
    "fetch": {
        "description": "Returns a `list` where each item is a `string` containing mail id, from, subject and a small preview of the content.",
        "example": [
            "metaMail = mail_login(user_mail_address, \"test\")",
            "mails = fetch(metaMail)",
            "results = []",
            "for mail in mails",
            "   segments = split(mail, char(10))",
            "   item = {}",
            "   item.mailId = segments[2][8:]",
            "   item.from = segments[3][6:]",
            "   item.subject = segments[4][9:]",
            "   item.preview = segments[5:]",
            "   push(results, item)",
            "end for",
            "print(results)"
        ]
    },
    "read": {
        "description": "Returns a `string` containing the content of a mail related to the provided mail id. The mail id argument can be obtained with `fetch`. In case the mail cannot be found this method will return \"Mail not found\".",
        "example": [
            "metaMail = mail_login(user_mail_address, \"test\")",
            "mails = fetch(metaMail)",
            "results = []",
            "for mail in mails",
            "   segments = split(mail, char(10))",
            "   mailId = segments[2][8:]",
            "   print(read(metaMail, mailId))",
            "end for"
        ]
    },
    "send": {
        "description": "Send a new mail to the provided email address. Keep in mind that the subject can not exceed 128 characters and the content size should not exceed 160000 characters. Returns `true` if the mail has been sent correctly, otherwise returns a `string` containing the error.",
        "example": [
            "metaMail = mail_login(user_mail_address, \"test\")",
            "result = send(metaMail, user_mail_address, \"test subject\", \"test message\")",
            "if typeof(result) == \"string\" then",
            "   print(\"There was an error while sending mail: \" + result)",
            "else",
            "   print(\"Mail got send successfully.\")",
            "end if"
        ]
    },
    "port_number": {
        "description": "Returns the `number` which is used for the port.",
        "example": [
            "router = get_router",
            "ports = used_ports(router)",
            "for port in ports",
            "   print(\"Port \" + port_number(port) + \" is in use!\")",
            "end for"
        ]
    },
    "is_closed": {
        "description": "Returns `true` if this port is closed, `false` if the port is open.",
        "example": [
            "router = get_router",
            "ports = used_ports(router)",
            "for port in ports",
            "   state = \"open\"",
            "   if (is_closed(port)) then state = \"closed\"",
            "   print(\"Port \" + port_number(port) + \" is \" + state + \"!\")",
            "end for"
        ]
    },
    "get_lan_ip": {
        "description": "Returns a `string` containing the local IP address of the computer to which the port is pointing.",
        "example": [
            "router = get_router",
            "ports = used_ports(router)",
            "for port in ports",
            "   print(\"Port \" + port_number(port) + \" is pointed to \" + get_lan_ip(port) + \"!\")",
            "end for"
        ]
    },
    "reset_password_coin": {
        "description": "Resets the password of the coin. Returns `true` if resetting was successful; otherwise, it will either return a `string` or `null`.",
        "example": [
            "blockchain = include_lib(\"/lib/blockchain.so\")",
            "coin = get_coin(blockchain, \"coinName\", \"user\", \"1234\")",
            "reset_password_coin(coin, \"12345\")"
        ]
    },
    "reset_ctf_password": {
        "description": "Resets the password of your CTF user. Returns `true` if resetting was successful; otherwise, it will return a `string` containing the reason for failure.",
        "example": [
            "reset_ctf_password(\"mysafepassword\")"
        ]
    },
    "reverse": {
        "description": "Reverses the order of all values in the `list`. This operation will mutate the `list`.",
        "example": [
            "myList = [42, 1, 3]",
            "reverse(myList)",
            "print(\"Reversed list: \" + myList.split(\", \"))"
        ]
    },
    "trim": {
        "description": "Returns a new `string` stripped of any spacing at the beginning or ending.",
        "example": [
            "myString = \"    42   \"",
            "print(trim(myString))"
        ]
    },
    "lastIndexOf": {
        "description": "Returns a `number` which indicates the last matching index of the provided value inside the `list`. Optionally an end index can be provided. In case the value does not exist inside the `string` a `-1` gets returned.",
        "example": [
            "myString = \"42 as an answer is wrong\"",
            "index = lastIndexOf(myString, \"wrong\")",
            "if index != -1 then",
            "   print(\"Invalid information spotted at: \" + index)",
            "else",
            "   print(\"Information seems valid.\")",
            "end if"
        ]
    }
}
